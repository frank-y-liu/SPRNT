      SUBROUTINE SPLPUP(USRMAT,MRELAS,NVARS,PRGOPT,DATTRV,
     *     BL,BU,IND,INFO,AMAT,IMAT,SIZEUP,ASMALL,ABIG)
C***BEGIN PROLOGUE  SPLPUP
C***REFER TO  SPLP
C     THE EDITING REQUIRED TO CONVERT THIS SUBROUTINE FROM SINGLE TO
C     DOUBLE PRECISION INVOLVES THE FOLLOWING CHARACTER STRING CHANGES.
C
C     USE AN EDITING COMMAND (CHANGE) /STRING-1/(TO)STRING-2/.
C     /REAL (12 BLANKS)/DOUBLE PRECISION/,/ABS(/DABS(/.
C
C     REVISED 810613-1130
C     REVISED YYMMDD-HHMM
C
C     THIS SUBROUTINE COLLECTS INFORMATION ABOUT THE BOUNDS AND MATRIX
C     FROM THE USER.  IT IS PART OF THE SPLP( ) PACKAGE.
C***ROUTINES CALLED  PCHNGS,PNNZRS,XERROR,XERRWV
C***END PROLOGUE  SPLPUP
      REAL             ABIG,AIJ,AMAT(*),AMN,AMX,ASMALL,BL(*),
     * BU(*),DATTRV(*),PRGOPT(*),R1,R2,XVAL,ZERO
      INTEGER IFLAG(10),IMAT(*),IND(*)
      LOGICAL SIZEUP,FIRST
C
C***FIRST EXECUTABLE STATEMENT  SPLPUP
      IOPT=1
      ZERO=0.E0
      GO TO 30001
20002 CONTINUE
      GO TO 30002
20003 IF (.NOT.(SIZEUP .AND. .NOT. FIRST)) GO TO 20004
      IF (.NOT.(AMN.LT.ASMALL .OR. AMX.GT.ABIG)) GO TO 20007
      NERR=22
      CALL XERROR( 'SPLP( ). A MATRIX ELEMENT''S SIZE IS OUT OF THE SPEC
     *IFIED RANGE.',63,NERR,IOPT)
      INFO=-NERR
      RETURN
20007 CONTINUE
20008 CONTINUE
20004 CONTINUE
C
20005 RETURN
C
C     PROCEDURE (CHECK USER-SUPPLIED BOUNDS)
C
C     CHECK THAT IND(*) VALUES ARE 1,2,3 OR 4.
C     ALSO CHECK CONSISTENCY OF UPPER AND LOWER BOUNDS.
30001 J=1
      N20010=NVARS
      GO TO 20011
20010 J=J+1
20011 IF ((N20010-J).LT.0) GO TO 20012
      IF (.NOT.(IND(J).LT.1 .OR. IND(J).GT.4)) GO TO 20014
      NERR=10
      CALL XERRWV('SPLP( ). INDEPENDENT VARIABLE (I1) IS NOT DEFINED.',
     *50,NERR,IOPT,1,J,I2,0,R1,R2)
      INFO=-NERR
      RETURN
20014 IF (.NOT.(IND(J).EQ.3)) GO TO 10001
      IF (.NOT.(BL(J).GT.BU(J))) GO TO 20017
      NERR=11
      CALL  XERRWV(   'SPLP( ).  LOWER BOUND (R1) AND UPPER BOUND (R2) F
     *OR INDEP. VARIABLE   (I1) ARE NOT CONSISTENT.', 94,NERR,IOPT,1,J,
     * I2, 2,BL(J),BU(J))
      INFO=-NERR
      RETURN
20017 CONTINUE
20018 CONTINUE
10001 CONTINUE
20015 GO TO 20010
20012 I=NVARS+1
      N20020=NVARS+MRELAS
      GO TO 20021
20020 I=I+1
20021 IF ((N20020-I).LT.0) GO TO 20022
      IF (.NOT.(IND(I).LT.1 .OR. IND(I).GT.4)) GO TO 20024
      NERR=12
      CALL XERRWV('SPLP( ). DEPENDENT VARIABLE (I1) IS NOT DEFINED.',
     * 48,NERR,IOPT,1,I-NVARS,I2,0,R1,R2)
      INFO=-NERR
      RETURN
20024 IF (.NOT.(IND(I).EQ.3)) GO TO 10002
      IF (.NOT.(BL(I).GT.BU(I))) GO TO 20027
      NERR=13
      CALL XERRWV(  'SPLP( ).  LOWER BOUND (R1) AND UPPER BOUND (R2) FOR
     * DEP. VARIABLE (I1) ARE NOT CONSISTENT.',90,NERR,IOPT,1,I,I2,2,
     * BL(I),BU(I))
      INFO=-NERR
      RETURN
20027 CONTINUE
20028 CONTINUE
10002 CONTINUE
20025 GO TO 20020
20022 CONTINUE
31001 GO TO 20002
C     PROCEDURE (GET UPDATES OR DATA FOR MATRIX FROM THE USER)
C
C     GET THE ELEMENTS OF THE MATRIX FROM THE USER.  IT WILL BE STORED
C     BY COLUMNS USING THE SPARSE STORAGE CODES OF RJ HANSON AND
C     JA WISNIEWSKI.
30002 IFLAG(1)=1
C
C     KEEP ACCEPTING ELEMENTS UNTIL THE USER IS FINISHED GIVING THEM.
C     LIMIT THIS LOOP TO 2*NVARS*MRELAS ITERATIONS.
      ITMAX=2*NVARS*MRELAS+1
      ITCNT=0
      FIRST=.TRUE.
C
C     CHECK ON THE ITERATION COUNT.
20030 ITCNT=ITCNT+1
      IF (.NOT.(ITCNT.GT.ITMAX)) GO TO 20032
      NERR=07
      CALL XERROR(  'SPLP( ). MORE THAN 2*NVARS*MRELAS ITERS. DEFINING O
     *R UPDATING MATRIX  DATA.',75,NERR,IOPT)
      INFO=-NERR
      RETURN
20032 AIJ=ZERO
      CALL USRMAT(I,J,AIJ,INDCAT,PRGOPT,DATTRV,IFLAG)
      IF (.NOT.(IFLAG(1).EQ.1)) GO TO 20035
      IFLAG(1)=2
      GO TO 20030
C
C     CHECK TO SEE THAT THE SUBSCRIPTS I AND J ARE VALID.
20035 IF (.NOT.(I.LT.1 .OR. I.GT.MRELAS .OR. J.LT.1 .OR. J.GT.NVARS)) GO
     * TO 20038
      IF (.NOT.(IFLAG(1).EQ.3)) GO TO 20041
      ASSIGN 20044 TO NPR003
      GO TO 30003
20044 GO TO 20031
20041 CONTINUE
20042 NERR=08
      CALL XERRWV(  'SPLP( ). ROW INDEX (I1) OR COLUMN INDEX (I2) IS OUT
     * OF RANGE.',61,NERR,IOPT,2,I,J,0,R1,R2)
      INFO=-NERR
      RETURN
C
C    IF INDCAT=0 THEN SET A(I,J)=AIJ.
C    IF INDCAT=1 THEN ACCUMULATE ELEMENT, A(I,J)=A(I,J)+AIJ.
20038 IF (.NOT.(INDCAT.EQ.0)) GO TO 20045
      CALL PCHNGS(I,AIJ,IPLACE,AMAT,IMAT,J)
      GO TO 20046
20045 IF (.NOT.(INDCAT.EQ.1)) GO TO 10003
      INDEX=-(I-1)
      CALL PNNZRS(INDEX,XVAL,IPLACE,AMAT,IMAT,J)
      IF (INDEX.EQ.I) AIJ=AIJ+XVAL
      CALL PCHNGS(I,AIJ,IPLACE,AMAT,IMAT,J)
      GO TO 20046
10003 NERR=09
      CALL XERRWV(  'SPLP( ). INDICATION FLAG (I1) FOR MATRIX DATA MUST
     *BE EITHER 0 OR 1.',68,NERR,IOPT,1,INDCAT,I2,0,R1,R2)
      INFO=-NERR
      RETURN
20046 ASSIGN 20048 TO NPR003
      GO TO 30003
20048 IF (.NOT.(IFLAG(1).EQ.3)) GO TO 20049
      GO TO 20031
20049 GO TO 20030
20031 CONTINUE
31002 GO TO 20003
C     PROCEDURE (CHECK ON SIZE OF MATRIX DATA)
C
C     RECORD THE LARGEST AND SMALLEST(IN MAGNITUDE) NONZERO ELEMENTS.
30003 IF (.NOT.(SIZEUP .AND. ABS(AIJ).NE.ZERO)) GO TO 20052
      IF (.NOT.(FIRST)) GO TO 20055
      AMX=ABS(AIJ)
      AMN=ABS(AIJ)
      IAMX=I
      JAMX=J
      IAMN=I
      JAMN=J
      FIRST=.FALSE.
      GO TO 20056
20055 IF (.NOT.(ABS(AIJ).GT.AMX)) GO TO 10004
      AMX=ABS(AIJ)
      IAMX=I
      JAMX=J
      GO TO 20056
10004 IF (.NOT.(ABS(AIJ).LT.AMN)) GO TO 10005
      AMN=ABS(AIJ)
      IAMN=I
      JAMN=J
10005 CONTINUE
20056 CONTINUE
20052 CONTINUE
20053 CONTINUE
31003 GO TO NPR003, (20044,20048)
      END
