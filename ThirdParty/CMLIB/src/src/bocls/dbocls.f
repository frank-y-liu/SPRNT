 
      SUBROUTINE DBOCLS (W,MDW,MCON,MROWS,NCOLS,BL,BU,IND,
     * IOPT,X,RNORMC,RNORM,MODE,RW,IW)
C     REVISED 830118-0920
C     REVISED YYMMDD-HHMM
C
C    PURPOSE
C    -------
C     THIS IS THE MAIN SUBPROGRAM THAT SOLVES THE LEAST SQUARES
C     PROBLEM CONSISTING OF LINEAR CONSTRAINTS
C
C              C*X = Y
C
C     AND LEAST SQUARES EQUATIONS
C
C              E*X = F
C
C     IN THIS FORMULATION THE VECTORS X AND Y ARE BOTH UNKNOWNS.
C     FURTHER, X AND Y MAY BOTH HAVE USER-SPECIFIED BOUNDS ON EACH
C     COMPONENT.  THE USER MUST HAVE DIMENSION STATEMENTS OF THE
C     FORM
C
C     DIMENSION W(MDW,NCOLS+MCON+1), BL(NCOLS+MCON),BU(NCOLS+MCON),
C               X(2*(NCOLS+MCON)+2+NX), RW(6*NCOLS+5*MCON)
C
C     INTEGER IND(NCOLS+MCON), IOPT(1+NI), IW(2*(NCOLS+MCON))
C
      DOUBLE PRECISION            W(MDW,*),BL(*),BU(*),X(*),RW(*)
      DOUBLE PRECISION            ONE,ZERO,T,T1,T2,WT,ANORM,CNORM,RNORM,
     *                            SRELPR,DDOT
      INTEGER IND(*),IOPT(*),IW(*),JOPT(05)
      LOGICAL CHECKL,FILTER,ACCUM,PRETRI
      SAVE IGO,ACCUM,CHECKL
      DATA IGO/0/
      LEVEL=1
      IF (.NOT.(IGO.EQ.0)) GO TO 20002
      GO TO 30001
20005 CONTINUE
      GO TO 30002
20006 IF (.NOT.(CHECKL)) GO TO 20007
      GO TO 30003
20010 CONTINUE
20007 CONTINUE
C
C     OPTIONALLY GO BACK TO THE USER FOR ACCUMULATION OF LEAST SQUARES
C     EQUATIONS AND DIRECTIONS FOR PROCESSING THESE EQUATIONS.
20002 CONTINUE
      GO TO 30004
20011 IF(ACCUM) RETURN
      GO TO 30005
20012 IGO=0
      RETURN
C     PROCEDURE(CHECK LENGTHS OF ARRAYS)
C
C     THIS FEATURE ALLOWS THE USER TO MAKE SURE THAT THE
C     ARRAYS ARE LONG ENOUGH FOR THE INTENDED PROBLEM SIZE AND USE.
30003 IF (.NOT.(LMDW.LT.MCON+MOUT)) GO TO 20013
      NERR=41
      NCHAR=88
      CALL XERRWV('DBOCLS(). THE ROW DIMENSION OF W(,)=(I1) MUST BE .GE.
     * THE NUMBER OF EFFECTIVE ROWS=(I2).',NCHAR,NERR,LEVEL,
     * 2,LMDW,MCON+MOUT, 0,RDUM,RDUM)
      ASSIGN 20016 TO NPR006
      GO TO 30006
20016 CONTINUE
20013 IF (.NOT.(LNDW.LT.NCOLS+MCON+1)) GO TO 20017
      NERR=42
      NCHAR=75
      CALL XERRWV('DBOCLS(). THE COLUMN DIMENSION OF W(,)=(I1) MUST BE .
     *GE. NCOLS+MCON+1=(I2).',NCHAR,NERR,LEVEL,
     * 2,LNDW,NCOLS+MCON+1, 0,RDUM,RDUM)
      ASSIGN 20020 TO NPR006
      GO TO 30006
20020 CONTINUE
20017 IF (.NOT.(LLB.LT.NCOLS+MCON)) GO TO 20021
      NERR=43
      NCHAR=94
      CALL XERRWV('DBOCLS(). THE DIMENSIONS OF THE ARRAYS BL(),BU(), AND
     * IND()=(I1) MUST BE .GE. NCOLS+MCON=(I2).',NCHAR,NERR,LEVEL,
     * 2,LLB,NCOLS+MCON, 0,RDUM,RDUM)
      ASSIGN 20024 TO NPR006
      GO TO 30006
20024 CONTINUE
20021 IF (.NOT.(LLX.LT.LENX)) GO TO 20025
      NERR=44
      NCHAR=71
      CALL XERRWV('DBOCLS(). THE DIMENSION OF X()=(I1) MUST BE .GE. THE
     * REQD. LENGTH=(I2).',NCHAR,NERR,LEVEL,
     * 2,LLX,LENX, 0,RDUM,RDUM)
      ASSIGN 20028 TO NPR006
      GO TO 30006
20028 CONTINUE
20025 IF (.NOT.(LLRW.LT.6*NCOLS+5*MCON)) GO TO 20029
      NERR=45
      NCHAR=70
      CALL XERRWV('DBOCLS(). THE DIMENSION OF RW()=(I1) MUST BE .GE. 6*N
     *COLS+5*MCON=(I2).',NCHAR,NERR,LEVEL,
     * 2,LLRW,6*NCOLS+5*MCON, 0,RDUM,RDUM)
      ASSIGN 20032 TO NPR006
      GO TO 30006
20032 CONTINUE
20029 IF (.NOT.(LLIW.LT.2*NCOLS+2*MCON)) GO TO 20033
      NERR=46
      NCHAR=69
      CALL XERRWV('DBOCLS() THE DIMENSION OF IW()=(I1) MUST BE .GE. 2*NC
     *OLS+2*MCON=(I2).',NCHAR,NERR,LEVEL,
     * 2,LLIW,2*NCOLS+2*MCON,0,RDUM,RDUM)
      ASSIGN 20036 TO NPR006
      GO TO 30006
20036 CONTINUE
20033 IF (.NOT.(LIOPT.LT.LP+1)) GO TO 20037
      NERR=47
      NCHAR=72
      CALL XERRWV('DBOCLS(). THE DIMENSION OF IOPT()=(I1) MUST BE .GE. T
     *HE REQD. LEN.=(I2).',NCHAR,NERR,LEVEL,
     * 2,LIOPT,LP+1,0,RDUM,RDUM)
      ASSIGN 20040 TO NPR006
      GO TO 30006
20040 CONTINUE
20037 GO TO 20010
C     PROCEDURE(CHECK VALIDITY OF INPUT DATA)
C
C     SEE THAT MDW IS .GT.0. GROSS CHECK ONLY.
30001 IF (.NOT.(MDW.LE.0)) GO TO 20041
      NERR=53
      NCHAR=36
      CALL XERRWV('DBOCLS(). MDW=(I1) MUST BE POSITIVE.',
     * NCHAR,NERR,LEVEL,
     * 1,MDW,IDUM,0,RDUM,RDUM)
      ASSIGN 20044 TO NPR006
      GO TO 30006
20044 CONTINUE
C
C     SEE THAT NUMBER OF CONSTRAINTS IS NONNEGATIVE.
20041 IF (.NOT.(MCON.LT.0)) GO TO 20045
      NERR=54
      NCHAR=40
      CALL XERRWV('DBOCLS(). MCON=(I1) MUST BE NONNEGATIVE.',
     * NCHAR,NERR,LEVEL,
     * 1,MCON,IDUM,0,RDUM,RDUM)
      ASSIGN 20048 TO NPR006
      GO TO 30006
20048 CONTINUE
C
C     SEE THAT NUMBER OF UNKNOWNS IS POSITIVE.
20045 IF (.NOT.(NCOLS.LE.0)) GO TO 20049
      NERR=55
      NCHAR=59
      CALL XERRWV('DBOCLS(). NCOLS=(I1) THE NO. OF VARIABLES MUST BE POS
     *ITIVE.', NCHAR,NERR,LEVEL,
     * 1,NCOLS,IDUM,0,RDUM,RDUM)
      ASSIGN 20052 TO NPR006
      GO TO 30006
20052 CONTINUE
C
C     SEE THAT CONSTRAINT INDICATORS ARE ALL WELL-DEFINED.
20049 J=1
      N20053=NCOLS+MCON
      GO TO 20054
20053 J=J+1
20054 IF ((N20053-J).LT.0) GO TO 20055
      IF (.NOT.(IND(J).LT.1 .OR. IND(J).GT.4)) GO TO 20057
      NERR=56
      NCHAR=46
      CALL XERRWV('DBOCLS(). FOR J=(I1), IND(J)=(I2) MUST BE 1-4.',
     * NCHAR,NERR,LEVEL,
     * 2,J,IND(J),0,RDUM,RDUM)
      ASSIGN 20060 TO NPR006
      GO TO 30006
20060 CONTINUE
20057 GO TO 20053
C
C     SEE THAT BOUNDS ARE CONSISTENT.
20055 J=1
      N20061=NCOLS+MCON
      GO TO 20062
20061 J=J+1
20062 IF ((N20061-J).LT.0) GO TO 20063
      IF (.NOT.(IND(J).EQ.3)) GO TO 20065
      IF (.NOT.(BL(J) .GT. BU(J))) GO TO 20068
      NERR=57
      NCHAR=58
      CALL XERRWV('DBOCLS(). FOR J=(I1), BOUND BL(J)=(R1) IS .GT. BU(J)=
     *(R2).', NCHAR,NERR,LEVEL,
     * 1,J,IDUM, 2,BL(J),BU(J))
      ASSIGN 20071 TO NPR006
      GO TO 30006
20071 CONTINUE
20068 CONTINUE
20065 GO TO 20061
20063 GO TO 20005
C     PROCEDURE(PROCESS OPTION ARRAY)
30002 ZERO=0.D0
      ONE=1.D0
      SRELPR=D1MACH(4)
      CHECKL=.FALSE.
      FILTER=.TRUE.
      LENX=2*(NCOLS+MCON)+2
      LIOPT=17
      ISCALE=1
      IGO=1
      ACCUM=.FALSE.
      PRETRI=.TRUE.
      LOPT=0
      MOPT=0
      LP=0
      LDS=0
20072 LP=LP+LDS
      LIOPT=LIOPT+LDS
      IP=IOPT(LP+1)
      JP=IABS(IP)
C
C     TEST FOR NO MORE OPTIONS.
      IF (.NOT.(IP.EQ.99)) GO TO 20074
      IF(LOPT.EQ.0)LOPT=-(LP+2)
      IF(MOPT.EQ.0)MOPT=-(IABS(LOPT)+7)
      IF (.NOT.(LOPT.LT.0)) GO TO 20077
      LBOU=IABS(LOPT)
      GO TO 20078
20077 LBOU=LOPT-15
C
C     SEND COL. SCALING TO DBOLS().
20078 IOPT(LBOU)=4
      IOPT(LBOU+1)=1
C
C     PASS AN OPTION ARRAY FOR DBOLSM().
      IOPT(LBOU+2)=5
C
C     LOC. OF OPTION ARRAY FOR DBOLSM( ).
      IOPT(LBOU+3)=8
C
C     SKIP TO START OF USER-GIVEN OPTION ARRAY FOR DBOLS().
      IOPT(LBOU+4)=6
      IOPT(LBOU+6)=99
      IF (.NOT.(LOPT.GT.0)) GO TO 20080
      IOPT(LBOU+5)=LOPT-LBOU+1
      GO TO 20081
20080 IOPT(LBOU+4)=-IOPT(LBOU+4)
20081 IF (.NOT.(MOPT.LT.0)) GO TO 20083
      LBOUM=IABS(MOPT)
      GO TO 20084
20083 LBOUM=MOPT-8
C
C     CHANGE PRETRIANGULARIZATION FACTOR IN DBOLSM().
20084 IOPT(LBOUM)=5
      IOPT(LBOUM+1)=NCOLS+MCON+1
C
C     PASS WEIGHT TO DBOLSM() FOR RANK TEST.
      IOPT(LBOUM+2)=6
      IOPT(LBOUM+3)=NCOLS+MCON+2
      IOPT(LBOUM+4)=MCON
C
C     SKIP TO USER-GIVEN OPTION ARRAY FOR DBOLSM( ).
      IOPT(LBOUM+5)=1
      IOPT(LBOUM+7)=99
      IF (.NOT.(MOPT.GT.0)) GO TO 20086
      IOPT(LBOUM+6)=MOPT-LBOUM+1
      GO TO 20087
20086 IOPT(LBOUM+5)=-IOPT(LBOUM+5)
20087 GO TO 20073
20074 IF (.NOT.(JP.EQ.99)) GO TO 10001
      LDS=1
      GO TO 20072
10001 IF (.NOT.(JP.EQ.1)) GO TO 10002
      IF (.NOT.(IP.GT.0)) GO TO 20089
C
C     SET UP DIRECTION FLAG LOCATION, ROW STACKING POINTER
C     LOCATION, AND LOCATION FOR NUMBER OF NEW ROWS.
      LOCACC=LP+2
C
C                  IOPT(LOCACC-1)=OPTION NUMBER FOR SEQ. ACCUMULATION.
C     CONTENTS..   IOPT(LOCACC  )=USER DIRECTION FLAG, 1 OR 2.
C                  IOPT(LOCACC+1)=ROW STACKING POINTER.
C                  IOPT(LOCACC+2)=NUMBER OF NEW ROWS TO PROCESS.
C     USER ACTION WITH THIS OPTION..
C      (SET UP OPTION DATA FOR SEQ. ACCUMULATION IN IOPT(*).)
C      (MOVE BLOCK OF EQUATIONS INTO W(*,*)  STARTING AT FIRST
C       ROW OF W(*,*) BELOW THE ROWS FOR THE CONSTRAINT MATRIX C.
C       SET IOPT(LOCACC+2)=NO. OF LEAST SQUARES EQUATIONS IN BLOCK.
C              LOOP
C              CALL DBOCLS()
C
C                  IF(IOPT(LOCACC) .EQ. 1) THEN
C                      STACK EQUAS. INTO W(*,*), STARTING AT
C                      ROW IOPT(LOCACC+1).
C                       INTO W(*,*).
C                       SET IOPT(LOCACC+2)=NO. OF EQUAS.
C                      IF LAST BLOCK OF EQUAS., SET IOPT(LOCACC)=2.
C                  ELSE IF IOPT(LOCACC) .EQ. 2) THEN
C                      (PROCESS IS OVER. EXIT LOOP.)
C                  ELSE
C                      (ERROR CONDITION. SHOULD NOT HAPPEN.)
C                  END IF
C              END LOOP
      IOPT(LOCACC+1)=MCON+1
      ACCUM=.TRUE.
      IOPT(LOCACC)=IGO
20089 LDS=4
      GO TO 20072
10002 IF (.NOT.(JP.EQ.2)) GO TO 10003
      IF (.NOT.(IP.GT.0)) GO TO 20092
C
C     GET ACTUAL LENGTHS OF ARRAYS FOR CHECKING AGAINST NEEDS.
      LOCDIM=LP+2
C
C     LMDW.GE.MCON+MOUT
C     LNDW.GE.NCOLS+MCON+1
C     LLB .GE.NCOLS+MCON
C     LLX .GE.2*(NCOLS+MCON)+2+EXTRA REQD. IN OPTIONS.
C     LLRW.GE.6*NCOLS+5*MCON
C     LLIW.GE.2*(NCOLS+MCON)
C     LIOP.GE. AMOUNT REQD. FOR OPTION ARRAY.
      LMDW=IOPT(LOCDIM  )
      LNDW=IOPT(LOCDIM+1)
      LLB= IOPT(LOCDIM+2)
      LLX= IOPT(LOCDIM+3)
      LLRW=IOPT(LOCDIM+4)
      LLIW=IOPT(LOCDIM+5)
      LIOPT=IOPT(LOCDIM+6)
      CHECKL=.TRUE.
20092 LDS=8
      GO TO 20072
C
C     OPTION TO MODIFY THE COLUMN SCALING.
10003 IF (.NOT.(JP.EQ.3)) GO TO 10004
      IF (.NOT.(IP.GT.0)) GO TO 20095
      ISCALE=IOPT(LP+2)
C
C     SEE THAT ISCALE IS 1 THRU 3.
      IF (.NOT.(ISCALE.LT.1 .OR. ISCALE.GT.3)) GO TO 20098
      NERR=48
      NCHAR=41
      CALL XERRWV('DBOCLS(). ISCALE OPTION=(I1) MUST BE 1-3.',
     * NCHAR,NERR,LEVEL,
     * 1,ISCALE,IDUM,0,RDUM,RDUM)
      ASSIGN 20101 TO NPR006
      GO TO 30006
20101 CONTINUE
20098 CONTINUE
20095 LDS=2
      GO TO 20072
C
C     IN THIS OPTION THE USER HAS PROVIDED SCALING.  THE
C     SCALE FACTORS FOR THE COLUMNS BEGIN IN X(NCOLS+IOPT(LP+2)).
10004 IF (.NOT.(JP.EQ.4)) GO TO 10005
      IF (.NOT.(IP.GT.0)) GO TO 20102
      ISCALE=4
      IF (.NOT.(IOPT(LP+2).LE.0)) GO TO 20105
      NERR=49
      NCHAR=86
      CALL XERRWV('DBOCLS(). OFFSET PAST X(NCOLS) (I1) FOR USER-PROVIDED
     * COLUMN SCALING MUST BE POSITIVE.',
     * NCHAR,NERR,LEVEL,
     * 1,IOPT(LP+2),IDUM,0,RDUM,RDUM)
      ASSIGN 20108 TO NPR006
      GO TO 30006
20108 CONTINUE
20105 CALL DCOPY(NCOLS,X(NCOLS+IOPT(LP+2)),1,RW,1)
      LENX=LENX+NCOLS
      J=1
      N20109=NCOLS
      GO TO 20110
20109 J=J+1
20110 IF ((N20109-J).LT.0) GO TO 20111
      IF (.NOT.(RW(J).LE.ZERO)) GO TO 20113
      NERR=50
      NCHAR=84
      CALL XERRWV('DBOCLS(). EACH PROVIDED COL. SCALE FACTOR MUST BE POS
     *ITIVE. COMP. (I1)   NOW = (R1).',
     * NCHAR,NERR,LEVEL,
     * 1,J,IDUM,1,RW(J),RDUM)
      ASSIGN 20116 TO NPR006
      GO TO 30006
20116 CONTINUE
20113 GO TO 20109
20111 CONTINUE
20102 LDS=2
      GO TO 20072
C
C     IN THIS OPTION AN OPTION ARRAY IS PROVIDED TO DBOLS().
10005 IF (.NOT.(JP.EQ.5)) GO TO 10006
      IF (.NOT.(IP.GT.0)) GO TO 20117
      LOPT=IOPT(LP+2)
20117 LDS=2
      GO TO 20072
C
C     IN THIS OPTION AN OPTION ARRAY IS PROVIDED TO DBOLSM().
10006 IF (.NOT.(JP.EQ.6)) GO TO 10007
      IF (.NOT.(IP.GT.0)) GO TO 20120
      MOPT=IOPT(LP+2)
20120 LDS=2
      GO TO 20072
C
C     THIS OPTION USES THE NEXT LOC OF IOPT(*) AS A
C     POINTER VALUE TO SKIP TO NEXT.
10007 IF (.NOT.(JP.EQ.7)) GO TO 10008
      IF (.NOT.(IP.GT.0)) GO TO 20123
      LP=IOPT(LP+2)-1
      LDS=0
      GO TO 20124
20123 LDS=2
20124 GO TO 20072
C
C     THIS OPTION AVOIDS THE CONSTRAINT RESOLVING PHASE FOR
C     THE LINEAR CONSTRAINTS C*X=Y.
10008 IF (.NOT.(JP.EQ.8)) GO TO 10009
      FILTER=.NOT.(IP.GT.0)
      LDS=1
      GO TO 20072
C
C     THIS OPTION SUPPRESSES PRETIRANGULARIZATION OF THE LEAST
C     SQUARES EQATIONS.
10009 IF (.NOT.(JP.EQ.9)) GO TO 10010
      PRETRI=.NOT.(IP.GT.0)
      LDS=1
      GO TO 20072
C
C     NO VALID OPTION NUMBER WAS NOTED. THIS IS AN ERROR CONDITION.
10010 NERR=51
      NCHAR=48
      CALL XERRWV('DBOCLS(). THE OPTION NUMBER=(I1) IS NOT DEFINED.',
     * NCHAR,NERR,LEVEL,
     * 1,JP,IDUM,0,IDUM,IDUM)
      ASSIGN 20126 TO NPR006
      GO TO 30006
20126 CONTINUE
20075 GO TO 20072
20073 GO TO 20006
C     PROCEDURE(ACCUMULATE LEAST SQUARES EQUATIONS)
30004 IF (.NOT.(ACCUM)) GO TO 20127
      MROWS=IOPT(LOCACC+1)-1-MCON
      INROWS=IOPT(LOCACC+2)
      MNEW=MROWS+INROWS
      IF (.NOT.(MNEW.LT.0 .OR. MNEW+MCON.GT.MDW)) GO TO 20130
      NERR=52
      NCHAR=66
      CALL XERRWV('DBOCLS(). NO. OF ROWS=(I1) MUST BE .GE. 0 .AND. .LE.
     *MDW-MCON=(I2).',NCHAR,NERR,LEVEL,
     *2,MNEW,MDW-MCON,0,RDUM,RDUM)
      ASSIGN 20133 TO NPR006
      GO TO 30006
20133 CONTINUE
20130 CONTINUE
20127 CONTINUE
C
C     USE THE SOFTWARE OF DBOLS( ) FOR THE TRIANGULARIZATION OF THE
C     LEAST SQUARES MATRIX.  THIS MAY INVOLVE A SYSTALTIC INTERCHANGE
C     OF PROCESSING POINTERS BETWEEN THE CALLING AND CALLED (DBOLS())
C     PROGRAM UNITS.
20128 JOPT(01)=1
      JOPT(02)=2
      JOPT(04)=MROWS
      JOPT(05)=99
      IRW=NCOLS+1
      IIW=1
      IF (.NOT.(ACCUM.OR.PRETRI)) GO TO 20134
      CALL DBOLS(W(MCON+1,1),MDW,MOUT,NCOLS,BL,BU,IND,
     * JOPT,X,RNORM,MODE,RW(IRW),IW(IIW))
      GO TO 20135
20134 MOUT=MROWS
20135 CONTINUE
20136 IF (.NOT.(ACCUM)) GO TO 20137
      ACCUM=IOPT(LOCACC).EQ.1
      IOPT(LOCACC+1)=JOPT(03)+MCON
      MROWS=MIN0(NCOLS+1,MNEW)
20137 CONTINUE
20138 GO TO 20011
C     PROCEDURE(SOLVE CONSTRAINED AND BOUNDED LEAST SQUARES PROBLEM)
C
C     MOVE RIGHT HAND SIDE OF LEAST SQUARES EQUATIONS.
30005 CALL DCOPY(MOUT,W(MCON+1,NCOLS+1),1,W(MCON+1,NCOLS+MCON+1),1)
      IF (.NOT.(MCON.GT.0 .AND. FILTER)) GO TO 20140
C
C     PROJECT THE LINEAR CONSTRAINTS INTO A REACHABLE SET.
      I=1
      N20143=MCON
      GO TO 20144
20143 I=I+1
20144 IF ((N20143-I).LT.0) GO TO 20145
      CALL DCOPY(NCOLS,W(I,1),MDW,W(MCON+1,NCOLS+I),1)
      GO TO 20143
C
C      PLACE (-)IDENTITY MATRIX AFTER CONSTRAINT DATA.
20145 J=NCOLS+1
      N20147=NCOLS+MCON+1
      GO TO 20148
20147 J=J+1
20148 IF ((N20147-J).LT.0) GO TO 20149
      W(1,J)=ZERO
      CALL DCOPY(MCON,W(1,J),0,W(1,J),1)
      GO TO 20147
20149 W(1,NCOLS+1)=-ONE
      CALL DCOPY(MCON,W(1,NCOLS+1),0,W(1,NCOLS+1),MDW+1)
C
C     OBTAIN A 'FEASIBLE POINT' FOR THE LINEAR CONSTRAINTS.
      JOPT(01)=99
      IRW=NCOLS+1
      IIW=1
      CALL DBOLS(W,MDW,MCON,NCOLS+MCON,BL,BU,IND,JOPT,X,
     * RNORMC,MODEC,RW(IRW),IW(IIW))
C
C     ENLARGE THE BOUNDS SET, IF REQUIRED, TO INCLUDE POINTS THAT
C     CAN BE REACHED.
      J=NCOLS+1
      N20151=NCOLS+MCON
      GO TO 20152
20151 J=J+1
20152 IF ((N20151-J).LT.0) GO TO 20153
      ICASE=IND(J)
      IF (.NOT.(ICASE.LT.4)) GO TO 20155
      T=DDOT(NCOLS,W(MCON+1,J),1,X,1)
20155 NX0162=ICASE
      IF (NX0162.LT.1.OR.NX0162.GT.4) GO TO 20162
      GO TO (20158,20159,20160,20161), NX0162
20158 BL(J)=DMIN1(T,BL(J))
      GO TO 20163
20159 BU(J)=DMAX1(T,BU(J))
      GO TO 20163
20160 BL(J)=DMIN1(T,BL(J))
      BU(J)=DMAX1(T,BU(J))
      GO TO 20163
20161 CONTINUE
20162 CONTINUE
20163 GO TO 20151
C
C     MOVE CONSTRAINT DATA BACK TO THE ORIGINAL AREA.
20153 J=NCOLS+1
      N20164=NCOLS+MCON
      GO TO 20165
20164 J=J+1
20165 IF ((N20164-J).LT.0) GO TO 20166
      CALL DCOPY(NCOLS,W(MCON+1,J),1,W(J-NCOLS,1),MDW)
      GO TO 20164
20166 CONTINUE
20140 CONTINUE
20141 IF (.NOT.(MCON.GT.0)) GO TO 20168
      J=NCOLS+1
      N20171=NCOLS+MCON
      GO TO 20172
20171 J=J+1
20172 IF ((N20171-J).LT.0) GO TO 20173
      W(MCON+1,J)=ZERO
      CALL DCOPY(MOUT,W(MCON+1,J),0,W(MCON+1,J),1)
      GO TO 20171
C
C     PUT IN (-)IDENTITY MATRIX (POSSIBLY) ONCE AGAIN.
20173 J=NCOLS+1
      N20175=NCOLS+MCON+1
      GO TO 20176
20175 J=J+1
20176 IF ((N20175-J).LT.0) GO TO 20177
      W(1,J)=ZERO
      CALL DCOPY(MCON,W(1,J),0,W(1,J),1)
      GO TO 20175
20177 W(1,NCOLS+1)=-ONE
      CALL DCOPY(MCON,W(1,NCOLS+1),0,W(1,NCOLS+1),MDW+1)
20168 CONTINUE
C
C     COMPUTE NOMINAL COLUMN SCALING FOR THE UNWEIGHTED MATRIX.
20169 CNORM=ZERO
      ANORM=ZERO
      J=1
      N20179=NCOLS
      GO TO 20180
20179 J=J+1
20180 IF ((N20179-J).LT.0) GO TO 20181
      T1=DASUM(MCON,W(1,J),1)
      T2=DASUM(MOUT,W(MCON+1,1),1)
      T=T1+T2
      IF(T.EQ.ZERO)T=ONE
      CNORM=DMAX1(CNORM,T1)
      ANORM=DMAX1(ANORM,T2)
      X(NCOLS+MCON+J)=ONE/T
      GO TO 20179
20181 NX0187=ISCALE
      IF (NX0187.LT.1.OR.NX0187.GT.4) GO TO 20187
      GO TO (20183,20184,20185,20186), NX0187
20183 GO TO 20188
C
C     SCALE COLS. (BEFORE WEIGHTING) TO HAVE LENGTH ONE.
20184 J=1
      N20189=NCOLS
      GO TO 20190
20189 J=J+1
20190 IF ((N20189-J).LT.0) GO TO 20191
      T=DNRM2(MCON+MOUT,W(1,J),1)
      IF(T.EQ.ZERO)T=ONE
      X(NCOLS+MCON+J)=ONE/T
      GO TO 20189
20191 GO TO 20188
C
C     SUPPRESS SCALING (USE UNIT MATRIX).
20185 X(NCOLS+MCON+1)=ONE
      CALL DCOPY(NCOLS,X(NCOLS+MCON+1),0,X(NCOLS+MCON+1),1)
      GO TO 20188
C
C     THE USER HAS PROVIDED SCALING.
20186 CALL DCOPY(NCOLS,RW,1,X(NCOLS+MCON+1),1)
20187 CONTINUE
20188 J=NCOLS+1
      N20193=NCOLS+MCON
      GO TO 20194
20193 J=J+1
20194 IF ((N20193-J).LT.0) GO TO 20195
      X(NCOLS+MCON+J)=ONE
      GO TO 20193
C
C     WEIGHT THE LEAST SQUARES EQUATIONS.
20195 WT=SRELPR
      IF(ANORM.GT.ZERO)WT=WT/ANORM
      IF(CNORM.GT.ZERO)WT=WT*CNORM
      I=1
      N20197=MOUT
      GO TO 20198
20197 I=I+1
20198 IF ((N20197-I).LT.0) GO TO 20199
      CALL DSCAL(NCOLS,WT,W(I+MCON,1),MDW)
      GO TO 20197
20199 CALL DSCAL(MOUT,WT,W(MCON+1,MCON+NCOLS+1),1)
      LRW=1
      LIW=1
C
C     SET THE NEW TRIANGULARIZATION FACTOR.
      X(2*(NCOLS+MCON)+1)=ZERO
C
C     SET THE WEIGHT TO USE IN COMPONENTS .GT. MCON,
C     WHEN MAKING LINEAR INDEPENDENCE TEST.
      X(2*(NCOLS+MCON)+2)=ONE/WT
      CALL DBOLS(W,MDW,MOUT+MCON,NCOLS+MCON,BL,BU,IND,IOPT(LBOU),X,
     * RNORM,MODE,RW(LRW),IW(LIW))
      RNORM=RNORM/WT
      GO TO 20012
C     PROCEDURE(RETURN TO USER PROGRAM UNIT)
30006 IGO=0
      IF(.TRUE.) RETURN
      GO TO NPR006, (20016,20020,20024,20028,20032,20036,20040,20044,200
     *48,20052,20060,20071,20101,20108,20116,20126,20133)
      END
