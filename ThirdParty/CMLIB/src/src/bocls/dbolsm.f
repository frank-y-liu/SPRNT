      SUBROUTINE DBOLSM(W,MDW,MINPUT,NCOLS,BL,BU,IND,
     *  IOPT,X,RNORM,MODE,RW,WW,SCL,IBASIS,IBB)
C
C     PURPOSE
C     -------
C     THIS IS THE MAIN SUBPROGRAM THAT SOLVES THE BOUNDED
C     LEAST SQUARES PROBLEM.  THE PROBLEM SOLVED HERE IS:
C
C     SOLVE E*X =  F  (LEAST SQUARES SENSE)
C     WITH BOUNDS ON SELECTED X VALUES.
C
C     REVISED 831102-1100
C     REVISED YYMMDD-HHMM
C
C     TO CHANGE THIS SUBPROGRAM FROM SINGLE TO DOUBLE PRECISION BEGIN
C     EDITING AT THE CARD 'C++'.
C     CHANGE THE STRINGS / ABS/ TO /DABS/, /DMAX1/ TO /DMAX1/,
C     /DAXPY/ TO /DAXPY/, /DCOPY/ TO /DCOPY/, /DMIN1/ TO /DMIN1/,
C     /DDOT/ TO /DDOT/, /DNRM2/ TO /DNRM2/, /DSQRT/ TO /DDSQRT/,
C     /DROT/ TO /DROT/, /DROTG/ TO /DROTG/, /D1MACH/ TO /D1MACH/,
C     /DSWAP/ TO /DSWAP/, /DASUM/ TO /DASUM/.
C     /DOUBLE PRECISION            / TO /DOUBLE PRECISION/.
C++
C
C     THIS VARIABLE REMAINS TYPE REAL.
      REAL RDUM
      DOUBLE PRECISION W(MDW,*),BL(*),BU(*), X(*),RW(*),WW(*),SCL(*)
      DOUBLE PRECISION             ALPHA, BETA, BOU, COLABV, COLBLO
      DOUBLE PRECISION             CL1, CL2, CL3, ONE, BIG
      DOUBLE PRECISION             FAC, RNORM, SC, SS, T, TOLIND, WT
      DOUBLE PRECISION TWO, T1, T2, WBIG, WLARGE, WMAG, XNEW
      DOUBLE PRECISION ZERO,  DABS, DMAX1, DMIN1, DDOT, DNRM2, DSQRT
      DOUBLE PRECISION             DASUM, D1MACH, TOLSZE
      INTEGER   IBASIS(*),IBB(*),IND(*),IOPT(*)
      LOGICAL FOUND,CONSTR
      INEXT(IDUM)=MIN0(IDUM+1,MROWS)
      LEVEL=1
C
C    VERIFY THAT THE PROBLEM DIMENSIONS ARE DEFINED PROPERLY.
      IF (.NOT.(MINPUT.LE.0)) GO TO 20002
      NERR=31
      NCHAR=51
      CALL XERRWV('DBOLSM(). THE NUMBER OF ROWS=(I1) MUST BE POSITIVE.',
     * NCHAR,NERR,LEVEL, 1,MINPUT,IDUM, 0,RDUM,RDUM)
      ASSIGN 20005 TO NPR001
      GO TO 30001
20005 CONTINUE
20002 IF (.NOT.(NCOLS.LE.0)) GO TO 20006
      NERR=32
      NCHAR=51
      CALL XERRWV('DBOLSM(). THE NUMBER OF COLS.=(I1) MUST BE POSTIVE.',
     * NCHAR,NERR,LEVEL, 1,NCOLS,IDUM, 0,RDUM,RDUM)
      ASSIGN 20009 TO NPR001
      GO TO 30001
20009 CONTINUE
20006 IF (.NOT.(MDW.LT.MINPUT)) GO TO 20010
      NERR=33
      NCHAR=78
      CALL XERRWV('DBOLSM(). THE ROW DIMENSION OF W(,)=(I1) MUST BE .GE.
     * THE NUMBER OF ROWS=(I2).',
     * NCHAR,NERR,LEVEL,
     * 2,MDW,MROWS, 0,RDUM,RDUM)
      ASSIGN 20013 TO NPR001
      GO TO 30001
20013 CONTINUE
C
C     VERIFY THAT BOUND INFORMATION IS CORRECT.
20010 J=1
      N20014=NCOLS
      GO TO 20015
20014 J=J+1
20015 IF ((N20014-J).LT.0) GO TO 20016
      IF (.NOT.(IND(J).LT.1 .OR. IND(J).GT.4)) GO TO 20018
      NERR=34
      NCHAR=58
      CALL XERRWV('DBOLSM(). FOR J=(I1) THE CONSTRAINT INDICATOR MUST BE
     * 1-4.',NCHAR,NERR,LEVEL,
     * 2, J,IND(J), 0,RDUM,RDUM)
      ASSIGN 20021 TO NPR001
      GO TO 30001
20021 CONTINUE
20018 CONTINUE
20019 GO TO 20014
20016 J=1
      N20022=NCOLS
      GO TO 20023
20022 J=J+1
20023 IF ((N20022-J).LT.0) GO TO 20024
      IF (.NOT.(IND(J).EQ.3)) GO TO 20026
      IF (.NOT.(BU(J).LT.BL(J))) GO TO 20029
      NERR=35
      NCHAR=71
      CALL XERRWV('DBOLSM(). FOR J=(I1) THE LOWER BOUND=(R1) IS .GT. THE
     * UPPER BOUND=(R2).',
     * NCHAR,NERR,LEVEL,
     * 1,J,IDUM, 2,BL(J),BU(J))
      ASSIGN 20032 TO NPR001
      GO TO 30001
20032 CONTINUE
20029 CONTINUE
20026 CONTINUE
20027 GO TO 20022
C
C     CHECK THAT PERMUTATION AND POLARITY ARRAYS HAVE BEEN SET.
20024 J=1
      N20033=NCOLS
      GO TO 20034
20033 J=J+1
20034 IF ((N20033-J).LT.0) GO TO 20035
      IF (.NOT.(IBASIS(J).LT.1 .OR. IBASIS(J).GT.NCOLS)) GO TO 20037
      NERR=36
      NCHAR=74
      CALL XERRWV('DBOLSM(). THE INPUT ORDER OF COLUMNS=(I1) IS NOT BETW
     *EEN 1 AND NCOLS=(I2).',
     * NCHAR,NERR,LEVEL,
     * 2, IBASIS(J),NCOLS, 0,RDUM,RDUM)
      ASSIGN 20040 TO NPR001
      GO TO 30001
20040 CONTINUE
20037 CONTINUE
20038 IF (.NOT.(IBB(J).LE.0)) GO TO 20041
      NERR=37
      NCHAR=81
      CALL XERRWV('DBOLSM(). THE BOUND POLARITY FLAG IN COMPONENT J=(I1)
     * MUST BE POSITIVE. NOW=(I2).',
     * NCHAR,NERR,LEVEL,
     * 2,J,IBB(J), 0,RDUM,RDUM)
      ASSIGN 20044 TO NPR001
      GO TO 30001
20044 CONTINUE
20041 CONTINUE
20042 GO TO 20033
20035 CONTINUE
      GO TO 30002
20045 CONTINUE
      GO TO 30003
20046 IF (.NOT.(IPRINT.GT.0)) GO TO 20047
      CALL DMOUT(MROWS,NCOLS+1,MDW,W,'('' PRETRI. INPUT MATRIX'')',-4)
      CALL SVOUT(NCOLS,BL,'('' LOWER BOUNDS'')',-4)
      CALL SVOUT(NCOLS,BU,'('' UPPER BOUNDS'')',-4)
20047 CONTINUE
20050 ITER=ITER+1
      IF (.NOT.(ITER.GT.ITMAX)) GO TO 20052
      NERR=21
      NCHAR=80
      CALL XERRWV('DBOLSM(). MORE THAN (I1)=ITMAX ITERATIONS SOLVING BOU
     *NDED LEAST SQUARES PROBLEM.',NCHAR,NERR,LEVEL,
     * 1,ITMAX,IDUM,0,RDUM,RDUM)
      ASSIGN 20055 TO NPR004
      GO TO 30004
20055 ASSIGN 20056 TO NPR001
      GO TO 30001
20056 CONTINUE
20052 CONTINUE
20053 CONTINUE
      GO TO 30005
20057 IF (.NOT.(.NOT. FOUND)) GO TO 20058
      ASSIGN 20061 TO NPR004
      GO TO 30004
20061 MODE=NSETB
      RETURN
20058 CONTINUE
      GO TO 30006
20062 CONTINUE
20059 CONTINUE
20060 GO TO 20050
20051 CONTINUE
C     PROCEDURE(RESCALE AND TRANSLATE VARIABLES)
30004 CALL DCOPY(NSETB,X,1,RW,1)
      X(1)=ZERO
      CALL DCOPY(NCOLS,X,0,X,1)
      J=1
      N20063=NSETB
      GO TO 20064
20063 J=J+1
20064 IF ((N20063-J).LT.0) GO TO 20065
      JCOL=IABS(IBASIS(J))
      X(JCOL)=RW(J)*DABS(SCL(JCOL))
      GO TO 20063
20065 J=1
      N20067=NCOLS
      GO TO 20068
20067 J=J+1
20068 IF ((N20067-J).LT.0) GO TO 20069
      IF(MOD(IBB(J),2).EQ.0)X(J)=BU(J)-X(J)
      GO TO 20067
20069 J=1
      N20071=NCOLS
      GO TO 20072
20071 J=J+1
20072 IF ((N20071-J).LT.0) GO TO 20073
      JCOL=IBASIS(J)
      IF(JCOL.LT.0)X(-JCOL)=BL(-JCOL)+X(-JCOL)
      GO TO 20071
20073 J=1
      N20075=NCOLS
      GO TO 20076
20075 J=J+1
20076 IF ((N20075-J).LT.0) GO TO 20077
      IF(SCL(J).LT.ZERO)X(J)=-X(J)
      GO TO 20075
20077 RNORM=ZERO
      I=NSETB+1
      N20079=MROWS
      GO TO 20080
20079 I=I+1
20080 IF ((N20079-I).LT.0) GO TO 20081
      T=W(I,NCOLS+1)
      RNORM=RNORM+T*T
      GO TO 20079
20081 RNORM=DSQRT(RNORM)
      GO TO NPR004, (20055,20061)
C     PROCEDURE(FIND A VARIABLE TO BECOME NON-ACTIVE)
C
C     COMPUTE (NEGATIVE) OF GRADIENT VECTOR, W=
C     (TRANSPOSE OF E)*(F-E*X).
30005 WW(1)=ZERO
      CALL DCOPY(NCOLS,WW,0,WW,1)
      J=NSETB+1
      N20083=NCOLS
      GO TO 20084
20083 J=J+1
20084 IF ((N20083-J).LT.0) GO TO 20085
      JCOL=IABS(IBASIS(J))
      WW(J)=
     *DDOT(MROWS-NSETB,W(INEXT(NSETB),J),1,W(INEXT(NSETB),NCOLS+1),1)
     * * DABS(SCL(JCOL))
      GO TO 20083
20085 IF (.NOT.(IPRINT.GT.0)) GO TO 20087
      CALL SVOUT(NCOLS,WW,'('' GRADIENT VALUES'')',-4)
      CALL IVOUT(NCOLS,IBASIS,'('' INTERNAL VARIABLE ORDER'')',-4)
      CALL IVOUT(NCOLS,IBB,'('' BOUND POLARITY'')',-4)
20087 CONTINUE
C
C     IF ACTIVE SET = NUMBER OF TOTAL ROWS, QUIT.
20090 IF (.NOT.(NSETB.EQ.MROWS)) GO TO 20092
      FOUND=.FALSE.
      GO TO 31005
C
C     CHOOSE AN EXTREMAL COMPONENT OF GRADIENT VECTOR
C     FOR A CANDIDATE TO BECOME NON-ACTIVE.
20092 WLARGE=-BIG
      WMAG=-BIG
      J=NSETB+1
      N20095=NCOLS
      GO TO 20096
20095 J=J+1
20096 IF ((N20095-J).LT.0) GO TO 20097
      T=WW(J)
      IF (T.EQ.BIG) GO TO 20095
      ITEMP=IBASIS(J)
      JCOL=IABS(ITEMP)
      T1=DNRM2(MVAL-NSETB,W(INEXT(NSETB),J),1)
      IF (.NOT.(ITEMP.LT.0)) GO TO 20099
      IF(MOD(IBB(JCOL),2).EQ.0)T=-T
      IF (T.LT.ZERO) GO TO 20095
      IF(MVAL.GT.NSETB)T=T1
      IF (.NOT.(T.GT.WLARGE)) GO TO 20102
      WLARGE=T
      JLARGE=J
20102 GO TO 20100
20099 IF(MVAL.GT.NSETB)T=T1
      IF (.NOT.( DABS(T).GT.WMAG)) GO TO 20105
      WMAG= DABS(T)
      JMAG=J
20105 CONTINUE
20100 GO TO 20095
C
C     CHOOSE MAG. OF LARGEST COMPONENT OF GRADIENT FOR CANDIDATE.
20097 JBIG=0
      WBIG=ZERO
      IF (.NOT.(WLARGE.GT.ZERO)) GO TO 20108
      JBIG=JLARGE
      WBIG=WLARGE
20108 IF (.NOT.(WMAG.GE.WBIG)) GO TO 20111
      JBIG=JMAG
      WBIG=WMAG
20111 IF (.NOT.(JBIG.EQ.0)) GO TO 20114
      FOUND=.FALSE.
      IF (.NOT.(IPRINT.GT.0)) GO TO 20117
      CALL IVOUT(0,I,'('' FOUND NO VARIABLE TO ENTER'')',-4)
20117 GO TO 31005
C
C     SEE IF THE INCOMING COL. IS SUFFICIENTLY INDEPENDENT.
C     THIS TEST IS MADE BEFORE AN ELIMINATION IS PERFORMED.
20114 IF (.NOT.(IPRINT.GT.0)) GO TO 20120
      CALL IVOUT(1,JBIG,'('' TRY TO BRING IN THIS COL.'')',-4)
20120 IF (.NOT.(MVAL.LE.NSETB)) GO TO 20123
      CL1=DNRM2(MVAL,W(1,JBIG),1)
      CL2=DABS(WT)*DNRM2(NSETB-MVAL,W(INEXT(MVAL),JBIG),1)
      CL3=DABS(WT)*DNRM2(MROWS-NSETB,W(INEXT(NSETB),JBIG),1)
      COLABV=DSQRT(CL1**2+CL2**2)
      COLBLO=CL3
      GO TO 20124
20123 CL1=DNRM2(NSETB,W(1,JBIG),1)
      CL2=DNRM2(MVAL-NSETB,W(INEXT(NSETB),JBIG),1)
      CL3=DABS(WT)*DNRM2(MROWS-MVAL,W(INEXT(MVAL),JBIG),1)
      COLABV=CL1
      COLBLO=DSQRT(CL2**2+CL3**2)
20124 IF (.NOT.(COLBLO .LE. TOLIND*COLABV)) GO TO 20126
      WW(JBIG)=BIG
      IF (.NOT.(IPRINT.GT.0)) GO TO 20129
      CALL IVOUT(0,I,'('' VARIABLE IS DEPENDENT; NOT USED.'')',-4)
20129 GO TO 20090
C
C     SWAP MATRIX COLS. NSETB+1 AND JBIG, PLUS POINTER INFO., AND
C     GRADIENT VALUES.
20126 NSETB=NSETB+1
      IF (.NOT.(NSETB.NE.JBIG)) GO TO 20132
      CALL DSWAP(MROWS,W(1,NSETB),1,W(1,JBIG),1)
      CALL DSWAP(    1,WW(NSETB),1   ,WW(JBIG),1)
      ITEMP=IBASIS(NSETB)
      IBASIS(NSETB)=IBASIS(JBIG)
      IBASIS(JBIG)=ITEMP
C
C     ELIMINATE ENTRIES BELOW THE PIVOT LINE IN COL. NSETB.
20132 IF (.NOT.(MROWS.GT.NSETB)) GO TO 20135
      I=MROWS
      N20138=NSETB+1
      GO TO 20139
20138 I=-1+I
20139 IF (-(N20138-I).LT.0) GO TO 20140
      IF (I.EQ.MVAL+1) GO TO 20138
      CALL DROTG(W(I-1,NSETB),W(I,NSETB),SC,SS)
      W(I,NSETB)=ZERO
      CALL DROT(NCOLS-NSETB+1,W(I-1,NSETB+1),MDW,W(I,NSETB+1),MDW,
     * SC,SS)
      GO TO 20138
20140 IF (.NOT.(MVAL.GE.NSETB)) GO TO 20142
      CALL DROTG(W(NSETB,NSETB),W(MVAL+1,NSETB),SC,SS)
      W(MVAL+1,NSETB)=ZERO
      CALL DROT(NCOLS-NSETB+1,W(NSETB,NSETB+1),MDW,W(MVAL+1,NSETB+1),
     * MDW,SC,SS)
20142 CONTINUE
20135 IF (.NOT.(W(NSETB,NSETB).EQ.ZERO)) GO TO 20145
      WW(NSETB)=BIG
      NSETB=NSETB-1
      IF (.NOT.(IPRINT.GT.0)) GO TO 20148
      CALL IVOUT(0,I,'('' PIVOT IS ZERO; NOT USED.'')',-4)
20148 GO TO 20090
C
C     CHECK THAT NEW VARIABLE IS MOVING IN THE RIGHT DIRECTION.
20145 ITEMP=IBASIS(NSETB)
      JCOL=IABS(ITEMP)
      XNEW=W(NSETB,NCOLS+1)/(W(NSETB,NSETB)*DABS(SCL(JCOL)))
      IF (.NOT.(ITEMP.LT.0)) GO TO 20153
      IF (WW(NSETB).GE.ZERO.AND.XNEW.LE.ZERO) GO TO 20152
      IF (WW(NSETB).LE.ZERO.AND.XNEW.GE.ZERO) GO TO 20152
20153 GO TO 20151
20152 WW(NSETB)=BIG
      NSETB=NSETB-1
      IF (.NOT.(IPRINT.GT.0)) GO TO 20156
      CALL IVOUT(0,I,'('' VARIABLE HAS BAD DIRECTION; NOT USED.'')',-4)
20156 CONTINUE
20157 GO TO 20090
20151 FOUND=.TRUE.
      GO TO 31005
20091 CONTINUE
31005 GO TO 20057
C     PROCEDURE(SOLVE THE TRIANGULAR SYSTEM)
30007 CALL DCOPY(NSETB,W(1,NCOLS+1),1,RW,1)
      J=NSETB
      GO TO 20160
20159 J=-1+J
20160 IF (-(1-J).LT.0) GO TO 20161
      RW(J)=RW(J)/W(J,J)
      JCOL=IABS(IBASIS(J))
      T=RW(J)
      IF(MOD(IBB(JCOL),2).EQ.0)RW(J)=-RW(J)
      CALL DAXPY(J-1,-T,W(1,J),1,RW,1)
      RW(J)=RW(J)/DABS(SCL(JCOL))
      GO TO 20159
20161 IF (.NOT.(IPRINT.GT.0)) GO TO 20163
      CALL SVOUT(NSETB,RW,'('' SOLN. VALUES'')',-4)
      CALL IVOUT(NSETB,IBASIS,'('' COLS. USED'')',-4)
20163 CONTINUE
31007 GO TO NPR007, (20166,20233)
C     PROCEDURE(MAKE MOVE AND UPDATE FACTORIZATION)
30006 ASSIGN 20166 TO NPR007
      GO TO 30007
C
C     SEE IF THE UNCONSTRAINED SOL. (OBTAINED BY SOLVING THE
C     TRIANGULAR SYSTEM) SATISFIES THE PROBLEM BOUNDS.
20166 ALPHA=TWO
      BETA=TWO
      X(NSETB)=ZERO
      J=1
      N20167=NSETB
      GO TO 20168
20167 J=J+1
20168 IF ((N20167-J).LT.0) GO TO 20169
      ITEMP=IBASIS(J)
      JCOL=IABS(ITEMP)
      T1=TWO
      T2=TWO
      IF (.NOT.(ITEMP.LT.0)) GO TO 20171
      BOU=ZERO
      GO TO 20172
20171 BOU=BL(JCOL)
20172 CONTINUE
20173 IF((-BOU).NE.BIG)BOU=BOU/DABS(SCL(JCOL))
      IF(RW(J).LE.BOU)T1=(X(J)-BOU)/(X(J)-RW(J))
      BOU=BU(JCOL)
      IF(BOU.NE.BIG)BOU=BOU/DABS(SCL(JCOL))
      IF(RW(J).GE.BOU)T2=(BOU-X(J))/(RW(J)-X(J))
C
C     IF NOT, THEN COMPUTE A STEP LENGTH SO THAT THE
C     VARIABLES REMAIN FEASIBLE.
      IF (.NOT.(T1.LT.ALPHA)) GO TO 20174
      ALPHA=T1
      JDROP1=J
20174 CONTINUE
20175 IF (.NOT.(T2.LT.BETA)) GO TO 20177
      BETA=T2
      JDROP2=J
20177 CONTINUE
20178 GO TO 20167
20169 CONSTR=ALPHA.LT.TWO .OR. BETA.LT.TWO
      IF (.NOT.(.NOT. CONSTR)) GO TO 20180
C
C     ACCEPT THE CANDIDATE BECAUSE IT SATISFIES THE STATED BOUNDS
C     ON THE VARIABLES.
      CALL DCOPY(NSETB,RW,1,X,1)
      GO TO 31006
C
C     TAKE A STEP THAT IS AS LARGE AS POSSIBLE WITH ALL
C     VARIABLES REMAINING FEASIBLE.
20180 J=1
      N20183=NSETB
      GO TO 20184
20183 J=J+1
20184 IF ((N20183-J).LT.0) GO TO 20185
      X(J)=X(J)+DMIN1(ALPHA,BETA)*(RW(J)-X(J))
      GO TO 20183
20185 IF (.NOT.(ALPHA.LE.BETA)) GO TO 20187
      JDROP2=0
      GO TO 20188
20187 JDROP1=0
20188 CONTINUE
20190 IF (.NOT.(JDROP1+JDROP2.GT.0.AND.NSETB.GT.0)) GO TO 20191
      JDROP=JDROP1+JDROP2
      ITEMP=IBASIS(JDROP)
      JCOL=IABS(ITEMP)
      IF (.NOT.(JDROP2.GT.0)) GO TO 20192
C
C     VARIABLE IS AT AN UPPER BOUND.  SUBTRACT MULTIPLE OF THIS COL.
C     FROM RIGHT HAND SIDE.
      T=BU(JCOL)
      IF (.NOT.(ITEMP.GT.0)) GO TO 20195
      BU(JCOL)=T-BL(JCOL)
      BL(JCOL)=-T
      ITEMP=-ITEMP
      SCL(JCOL)=-SCL(JCOL)
      I=1
      N20198=JDROP
      GO TO 20199
20198 I=I+1
20199 IF ((N20198-I).LT.0) GO TO 20200
      W(I,JDROP)=-W(I,JDROP)
      GO TO 20198
20200 GO TO 20196
20195 IBB(JCOL)=IBB(JCOL)+1
      IF(MOD(IBB(JCOL),2).EQ.0)T=-T
C     VARIABLE IS AT A LOWER BOUND.
20196 GO TO 20193
20192 IF (.NOT.(ITEMP.LT.ZERO)) GO TO 20202
      T=ZERO
      GO TO 20203
20202 T=-BL(JCOL)
      BU(JCOL)=BU(JCOL)+T
      ITEMP=-ITEMP
20203 CONTINUE
20193 CONTINUE
20194 CALL DAXPY(JDROP,T,W(1,JDROP),1,W(1,NCOLS+1),1)
C
C     MOVE CERTAIN COLS. LEFT TO ACHIEVE UPPER HESSENBERG FORM.
      CALL DCOPY(JDROP,W(1,JDROP),1,RW,1)
      J=JDROP+1
      N20205=NSETB
      GO TO 20206
20205 J=J+1
20206 IF ((N20205-J).LT.0) GO TO 20207
      IBASIS(J-1)=IBASIS(J)
      X(J-1)=X(J)
      CALL DCOPY(J,W(1,J),1,W(1,J-1),1)
      GO TO 20205
20207 IBASIS(NSETB)=ITEMP
      W(1,NSETB)=ZERO
      CALL DCOPY(MROWS-JDROP,W(1,NSETB),0,W(JDROP+1,NSETB),1)
      CALL DCOPY(JDROP,RW,1,W(1,NSETB),1)
C
C     TRANSFORM THE MATRIX FROM UPPER HESSENBERG FORM TO
C     UPPER TRIANGULAR FORM.
      NSETB=NSETB-1
      I=JDROP
      N20211=NSETB
      GO TO 20212
20211 I=I+1
20212 IF ((N20211-I).LT.0) GO TO 20213
C
C     LOOK FOR SMALL PIVOTS AND AVOID MIXING WEIGHTED AND
C     NONWEIGHTED ROWS.
      IF (.NOT.(I.EQ.MVAL)) GO TO 20215
      T=ZERO
      J=I
      N20218=NSETB
      GO TO 20219
20218 J=J+1
20219 IF ((N20218-J).LT.0) GO TO 20220
      JCOL=IABS(IBASIS(J))
      T1=DABS(W(I,J)*SCL(JCOL))
      IF (.NOT.(T1.GT.T)) GO TO 20222
      JBIG=J
      T=T1
20222 GO TO 20218
20220 GO TO 20210
20215 CALL DROTG(W(I,I),W(I+1,I),SC,SS)
      W(I+1,I)=ZERO
      CALL DROT(NCOLS-I+1,W(I,I+1),MDW,W(I+1,I+1),MDW,SC,SS)
      GO TO 20211
20213 GO TO 20209
C
C     THE TRIANGULARIZATION IS COMPLETED BY GIVING UP
C     THE HESSENBERG FORM AND TRIANGULARIZING A RECTANGULAR MATRIX.
20210 CALL DSWAP(MROWS,W(1,I),1,W(1,JBIG),1)
      CALL DSWAP(    1,WW(I),1,WW(JBIG),1)
      CALL DSWAP(    1,X(I),1,X(JBIG),1)
      ITEMP=IBASIS(I)
      IBASIS(I)=IBASIS(JBIG)
      IBASIS(JBIG)=ITEMP
      JBIG=I
      J=JBIG
      N20225=NSETB
      GO TO 20226
20225 J=J+1
20226 IF ((N20225-J).LT.0) GO TO 20227
      I=J+1
      N20229=MROWS
      GO TO 20230
20229 I=I+1
20230 IF ((N20229-I).LT.0) GO TO 20231
      CALL DROTG(W(J,J),W(I,J),SC,SS)
      W(I,J)=ZERO
      CALL DROT(NCOLS-J+1,W(J,J+1),MDW,W(I,J+1),MDW,SC,SS)
      GO TO 20229
20231 GO TO 20225
20227 CONTINUE
C
C     SEE IF THE REMAINING COEFFICIENTS ARE FEASIBLE.  THEY SHOULD
C     BE BECAUSE OF THE WAY MIN(ALPHA,BETA) WAS CHOSEN.  ANY THAT ARE
C     NOT FEASIBLE WILL BE SET TO THEIR BOUNDS AND
C     APPROPRIATELY TRANSLATED.
20209 JDROP1=0
      JDROP2=0
      ASSIGN 20233 TO NPR007
      GO TO 30007
20233 CALL DCOPY(NSETB,RW,1,X,1)
      J=1
      N20234=NSETB
      GO TO 20235
20234 J=J+1
20235 IF ((N20234-J).LT.0) GO TO 20236
      ITEMP=IBASIS(J)
      JCOL=IABS(ITEMP)
      IF (.NOT.(ITEMP.LT.0)) GO TO 20238
      BOU=ZERO
      GO TO 20239
20238 BOU=BL(JCOL)
20239 IF((-BOU).NE.BIG)BOU=BOU/DABS(SCL(JCOL))
      IF (.NOT.(X(J).LE.BOU)) GO TO 20241
      JDROP1=J
      GO TO 20190
20241 BOU=BU(JCOL)
      IF(BOU.NE.BIG)BOU=BOU/DABS(SCL(JCOL))
      IF (.NOT.(X(J).GE.BOU)) GO TO 20244
      JDROP2=J
      GO TO 20190
20244 GO TO 20234
20236 GO TO 20190
20191 CONTINUE
20181 CONTINUE
31006 GO TO 20062
C     PROCEDURE(INITIALIZE VARIABLES AND DATA VALUES)
C
C     PRETRIANGULARIZE RECTANGULAR ARRAYS OF CERTAIN SIZES
C     FOR INCREASED EFFICIENCY.
30003 IF (.NOT.(FAC*MINPUT.GT.NCOLS)) GO TO 20247
      J=1
      N20250=NCOLS+1
      GO TO 20251
20250 J=J+1
20251 IF ((N20250-J).LT.0) GO TO 20252
      I=MINPUT
      N20254=J+MVAL+1
      GO TO 20255
20254 I=-1+I
20255 IF (-(N20254-I).LT.0) GO TO 20256
      CALL DROTG(W(I-1,J),W(I,J),SC,SS)
      W(I,J)=ZERO
      CALL DROT(NCOLS-J+1,W(I-1,J+1),MDW,W(I,J+1),MDW,SC,SS)
      GO TO 20254
20256 GO TO 20250
20252 MROWS=NCOLS+MVAL+1
      GO TO 20248
20247 MROWS=MINPUT
C
C      SET THE X(*) ARRAY TO ZERO SO ALL COMPONENTS ARE DEFINED.
20248 X(1)=ZERO
      CALL DCOPY(NCOLS,X,0,X,1)
C
C     THE ARRAYS IBASIS(*), IBB(*) ARE INITIALIZED BY THE CALLING
C     PROGRAM UNIT.
C     THE COL. SCALING IS DEFINED IN THE CALLING PROGRAM UNIT.
C    'BIG' IS PLUS INFINITY ON THIS MACHINE.
      BIG=D1MACH(2)
      J=1
      N20258=NCOLS
      GO TO 20259
20258 J=J+1
20259 IF ((N20258-J).LT.0) GO TO 20260
      ICASE=IND(J)
      NX0266=ICASE
      IF (NX0266.LT.1.OR.NX0266.GT.4) GO TO 20266
      GO TO (20262,20263,20264,20265), NX0266
20262 BU(J)=BIG
      GO TO 20267
20263 BL(J)=-BIG
      GO TO 20267
20264 GO TO 20267
20265 BL(J)=-BIG
      BU(J)= BIG
20266 CONTINUE
20267 GO TO 20258
20260 J=1
      N20268=NCOLS
      GO TO 20269
20268 J=J+1
20269 IF ((N20268-J).LT.0) GO TO 20270
      IF (.NOT.((BL(J).LE.ZERO.AND.ZERO.LE.BU(J).AND.DABS(BU(J)).LT.
     *        DABS(BL(J))).OR.BU(J).LT.ZERO)) GO TO 20272
      T=BU(J)
      BU(J)=-BL(J)
      BL(J)=-T
      SCL(J)=-SCL(J)
      I=1
      N20275=MROWS
      GO TO 20276
20275 I=I+1
20276 IF ((N20275-I).LT.0) GO TO 20277
      W(I,J)=-W(I,J)
      GO TO 20275
20277 CONTINUE
C
C     INDICES IN SET T(=TIGHT) ARE DENOTED BY NEGATIVE VALUES
C     OF IBASIS(*).
20272 IF (.NOT.(BL(J).GE.ZERO)) GO TO 20279
      IBASIS(J)=-IBASIS(J)
      T=-BL(J)
      BU(J)=BU(J)+T
      CALL DAXPY(MROWS,T,W(1,J),1,W(1,NCOLS+1),1)
20279 GO TO 20268
20270 NSETB=0
      ITER=0
31003 GO TO 20046
C     PROCEDURE(PROCESS OPTION ARRAY)
30002 ZERO=0.E0
      FAC=0.75
      ONE=1.E0
      TWO=2.E0
      TOLIND=DSQRT(D1MACH(4))
      TOLSZE=DSQRT(D1MACH(4))
      ITMAX=5*MAX0(MROWS,NCOLS)
      WT=ONE
      MVAL=0
      IPRINT=0
C
C     CHANGES TO SOME PARAMETERS CAN OCCUR THROUGH THE OPTION
C     ARRAY, IOPT(*).  PROCESS THIS ARRAY LOOKING CAREFULLY
C     FOR INPUT DATA ERRORS.
      LP=0
      LDS=0
20282 LP=LP+LDS
C
C     TEST FOR NO MORE OPTIONS.
      IP=IOPT(LP+1)
      JP=IABS(IP)
      IF (.NOT.(IP.EQ.99)) GO TO 20284
      GO TO 20283
20284 IF (.NOT.(JP.EQ.99)) GO TO 10001
      LDS=1
      GO TO 20282
10001 IF (.NOT.(JP.EQ.1)) GO TO 10002
C
C     MOVE THE IOPT(*) PROCESSING POINTER.
      IF (.NOT.(IP.GT.0)) GO TO 20287
      LP=IOPT(LP+2)-1
      LDS=0
      GO TO 20288
20287 LDS=2
20288 GO TO 20282
10002 IF (.NOT.(JP.EQ.2)) GO TO 10003
C
C     CHANGE TOLERANCE FOR RANK DETERMINATION.
      IF (.NOT.(IP.GT.0)) GO TO 20290
      IOFF=IOPT(LP+2)
      IF (.NOT.(IOFF.LE.0)) GO TO 20293
      NERR=24
      NCHAR=89
      CALL XERRWV('DBOLSM(). THE OFFSET=(I1) BEYOND POSTION NCOLS=(I2)
     * MUST BE POSITIVE FOR OPTION NUMBER 2.',NCHAR,NERR,LEVEL,
     * 2,IOFF,NCOLS, 0,RDUM,RDUM)
      ASSIGN 20296 TO NPR001
      GO TO 30001
20296 CONTINUE
20293 TOLIND=X(NCOLS+IOFF)
      IF (.NOT.(TOLIND.LT.D1MACH(4))) GO TO 20297
      NERR=25
      NLEVEL=0
      NCHAR=88
      CALL XERRWV('DBOLSM(). THE TOLERANCE FOR RANK DETERMINATION=(R1) I
     *S LESS THAN MACHINE PRECISION=(R2).',NCHAR,NERR,NLEVEL,
     * 0,IDUM,IDUM, 2,TOLIND,D1MACH(4))
20297 CONTINUE
20290 LDS=2
      GO TO 20282
10003 IF (.NOT.(JP.EQ.3)) GO TO 10004
C
C     CHANGE BLOWUP FACTOR FOR ALLOWING VARIABLES TO BECOME
C     INACTIVE.
      IF (.NOT.(IP.GT.0)) GO TO 20300
      IOFF=IOPT(LP+2)
      IF (.NOT.(IOFF.LE.0)) GO TO 20303
      NERR=26
      NCHAR=89
      CALL XERRWV('DBOLSM(). THE OFFSET=(I1) BEYOND POSITION NCOLS=(I2)
     * MUST BE POSTIVE FOR OPTION NUMBER 3.', NCHAR,NERR,LEVEL,
     * 2,IOFF,NCOLS, 0,RDUM,RDUM)
      ASSIGN 20306 TO NPR001
      GO TO 30001
20306 CONTINUE
20303 TOLSZE=X(NCOLS+IOFF)
      IF (.NOT.(TOLSZE.LE.ZERO)) GO TO 20307
      NERR=27
      CALL XERRWV('DBOLSM(). THE RECIPROCAL OF THE BLOW-UP FACTOR FOR RE
     *JECTING VARIABLES MUST BE POSITIVE. NOW=(R1).',
     * NCHAR,NERR,LEVEL,
     * 0,IDUM,IDUM, 1,TOLSZE,RDUM)
      ASSIGN 20310 TO NPR001
      GO TO 30001
20310 CONTINUE
20307 CONTINUE
20300 LDS=2
      GO TO 20282
10004 IF (.NOT.(JP.EQ.4)) GO TO 10005
C
C     CHANGE THE MAX. NO. OF ITERATIONS ALLOWED.
      IF (.NOT.(IP.GT.0)) GO TO 20311
      ITMAX=IOPT(LP+2)
      IF (.NOT.(ITMAX.LE.0)) GO TO 20314
      NERR=28
      NCHAR=65
      CALL XERRWV('DBOLSM(). THE MAXIMUM NUMBER OF ITERATIONS=(I1) MUST
     * BE POSITIVE.',NCHAR,NERR,LEVEL,
     * 1,ITMAX,IDUM, 0,RDUM,RDUM)
      ASSIGN 20317 TO NPR001
      GO TO 30001
20317 CONTINUE
20314 CONTINUE
20311 LDS=2
      GO TO 20282
10005 IF (.NOT.(JP.EQ.5)) GO TO 10006
C
C     CHANGE THE FACTOR FOR PRETRIANGULARIZING THE DATA MATRIX.
      IF (.NOT.(IP.GT.0)) GO TO 20318
      IOFF=IOPT(LP+2)
      IF (.NOT.(IOFF.LE.0)) GO TO 20321
      NERR=29
      NCHAR=89
      CALL XERRWV('DBOLSM(). THE OFFSET=(I1) BEYOND POSITION NCOLS=(I2)
     * MUST BE POSTIVE FOR OPTION NUMBER 5.', NCHAR,NERR,LEVEL,
     * 2,IOFF,NCOLS, 0,RDUM,RDUM)
      ASSIGN 20324 TO NPR001
      GO TO 30001
20324 CONTINUE
20321 FAC=X(NCOLS+IOFF)
      IF (.NOT.(FAC.LT.ZERO)) GO TO 20325
      NERR=30
      NLEVEL=0
      NCHAR=104
      CALL XERRWV('DBOLSM(). THE FACTOR (NCOLS/MROWS) WHERE PRE-TRIANGUL
     *ARIZING IS PERFORMED MUST BE NONNEGATIVE. NOW=(R1).',
     * NCHAR,NERR,NLEVEL,
     * 0,IDUM,IDUM, 1,FAC,RDUM)
      ASSIGN 20328 TO NPR001
      GO TO 30001
20328 CONTINUE
20325 CONTINUE
20318 LDS=2
      GO TO 20282
10006 IF (.NOT.(JP.EQ.6)) GO TO 10007
C
C     CHANGE THE WEIGHTING FACTOR (FROM ONE) TO APPLY TO COMPONENTS
C     NUMBERED .GT. MVAL (INITIALLY SET TO 1.)  THIS TRICK IS NEEDED
C     FOR APPLICATIONS OF THIS SUBPROGRAM TO THE HEAVILY WEIGHTED
C     LEAST SQUARES PROBLEM THAT COME FROM EQUALITY CONSTRAINTS.
      IF (.NOT.(IP.GT.0)) GO TO 20329
      IOFF=IOPT(LP+2)
      MVAL=IOPT(LP+3)
      WT=X(NCOLS+IOFF)
20329 IF (.NOT.(MVAL.LT.0 .OR.MVAL.GT.MINPUT.OR.WT .LE. ZERO)) GO TO 203
     *32
      NERR=38
      NLEVEL=0
      NCHAR=116
      CALL XERRWV('DBOLSM(). THE ROW SEPARATOR TO APPLY WEIGHTING (I1) M
     *UST LIE BETWEEN 0 AND MROWS (I2). WEIGHT (R1) MUST BE POSITIVE.',
     * NCHAR,NERR,NLEVEL,
     * 2,MVAL,MINPUT, 1,WT,RDUM)
      ASSIGN 20335 TO NPR001
      GO TO 30001
20335 CONTINUE
20332 LDS=3
      GO TO 20282
C
C     TURN ON DEBUG OUTPUT.
10007 IF (.NOT.(JP.EQ.7)) GO TO 10008
      IF(IP.GT.0) IPRINT=1
      LDS=1
      GO TO 20282
10008 NERR=22
      NCHAR=46
      CALL XERRWV('DBOLSM. THE OPTION NUMBER=(I1) IS NOT DEFINED.',
     * NCHAR,NERR,LEVEL,1,IP,IDUM,0,RDUM,RDUM)
      ASSIGN 20336 TO NPR001
      GO TO 30001
20336 CONTINUE
20285 GO TO 20282
20283 CONTINUE
31002 GO TO 20045
C     PROCEDURE(RETURN TO USER PROGRAM UNIT)
30001 MODE=-NERR
C
C     THIS TEST IS ONLY FOR AVOIDING A COMPILE ERROR ON
C     THE A-GO-TO AFTER THE RETURN.
      IF(.TRUE.) RETURN
31001 GO TO NPR001, (20005,20009,20013,20021,20032,20040,20044,20056,202
     *96,20306,20310,20317,20324,20328,20335,20336)
      END
