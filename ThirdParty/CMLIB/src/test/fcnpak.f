C
C   DRIVER FOR TESTING CMLIB ROUTINES
C     SINGLE PRECISION LEGENDRE ROUTINES IN FCNPAK
C     DOUBLE PRECISION LEGENDRE ROUTINES IN FCNPAK
C
C    ONE INPUT DATA CARD IS REQUIRED
C         READ(LIN,1) KPRINT,TIMES
C    1    FORMAT(I1,E10.0)
C
C     KPRINT = 0   NO PRINTING
C              1   NO PRINTING FOR PASSED TESTS, SHORT MESSAGE
C                  FOR FAILED TESTS
C              2   PRINT SHORT MESSAGE FOR PASSED TESTS, FULLER
C                  INFORMATION FOR FAILED TESTS
C              3   PRINT COMPLETE QUICK-CHECK RESULTS
C
C                ***IMPORTANT NOTE***
C         ALL QUICK CHECKS USE ROUTINES R2MACH AND D2MACH
C         TO SET THE ERROR TOLERANCES.
C     TIMES IS A CONSTANT MULTIPLIER THAT CAN BE USED TO SCALE THE
C     VALUES OF R1MACH AND D1MACH SO THAT
C               R2MACH(I) = R1MACH(I) * TIMES   FOR I=3,4,5
C               D2MACH(I) = D1MACH(I) * TIMES   FOR I=3,4,5
C     THIS MAKES IT EASILY POSSIBLE TO CHANGE THE ERROR TOLERANCES
C     USED IN THE QUICK CHECKS.
C     IF TIMES .LE. 0.0 THEN TIMES IS DEFAULTED TO 1.0
C
C              ***END NOTE***
C
      COMMON/UNIT/LUN
      COMMON/MSG/ICNT,JTEST(38)
      COMMON/XXMULT/TIMES
      LUN=I1MACH(2)
      LIN=I1MACH(1)
      ITEST=1
C
C     READ KPRINT,TIMES PARAMETERS FROM DATA CARD..
C
      READ(LIN,1) KPRINT,TIMES
1     FORMAT(I1,E10.0)
      IF(TIMES.LE.0.) TIMES=1.
      CALL XSETUN(LUN)
      CALL XSETF(1)
      CALL XERMAX(1000)
C   TEST SINGLE PRECISION ROUTINES
      CALL FCNQX1(KPRINT,IPASS)
      ITEST=ITEST*IPASS
C   TEST DOUBLE PRECISION ROUTINES
      CALL FCNQX2(KPRINT,IPASS)
      ITEST=ITEST*IPASS
C
      IF(KPRINT.GE.1.AND.ITEST.NE.1) WRITE(LUN,2)
2     FORMAT(/' ***** WARNING -- AT LEAST ONE TEST FOR SUBLIBRARY FCNPAK
     1  HAS FAILED ***** ')
      IF(KPRINT.GE.1.AND.ITEST.EQ.1) WRITE(LUN,3)
3     FORMAT(/' ----- SUBLIBRARY FCNPAK PASSED ALL TESTS ----- ')
      END
      DOUBLE PRECISION FUNCTION D2MACH(I)
      DOUBLE PRECISION D1MACH
      COMMON/XXMULT/TIMES
      D2MACH=D1MACH(I)
      IF(I.EQ.1.OR. I.EQ.2) RETURN
      D2MACH = D2MACH * DBLE(TIMES)
      RETURN
      END
      REAL FUNCTION R2MACH(I)
      COMMON/XXMULT/TIMES
      R2MACH=R1MACH(I)
      IF(I.EQ.1.OR. I.EQ.2) RETURN
      R2MACH = R2MACH * TIMES
      RETURN
      END
      SUBROUTINE FCNQX1(KPRINT,IPASS)
      INTEGER KPRINT,IPASS
      COMMON/UNIT/LUN
      DIMENSION P(10),Q(10),R(10),C1(10),C2(10),IP(10),IQ(10),IR(10)
      DIMENSION IC1(10),IC2(10),PN(10),IPN(10)
      REAL P,Q,R,C1,C2,PN
      REAL DEG,THETA,DNU1,DZERO
      REAL X11,X12,X13,X21,X22,X23
      REAL NU
      IF(KPRINT.GE.2) WRITE(LUN,1)
    1 FORMAT(' ** TEST SINGLE PRECISION LEGENDRE FUNCTION ROUTINES IN FC
     2NPAK ** ',/)
      IPASS=1
      IRAD=0
      NRADPL=0
      DZERO=0.0
      NBITS=0
      CALL XSSET(IRAD,NRADPL,DZERO,NBITS)
      IERR=0
      DNU1=2000.4
      IF(I1MACH(13)*LOG10(FLOAT(I1MACH(10))).LT.150) DNU1=100.4
      IF (KPRINT.LE.2) GO TO 150
      IF (I1MACH(13).LT.500) WRITE(LUN,24)
   24 FORMAT('0ON COMPUTERS WITH MAXIMUM EXPONENT LESS THAN 150, A'/
     1' SMALL TEST VALUE FOR NU IS USED. IF LARGER THAN OR EQUAL 150,'/
     2' A LARGER NU IS USED. THIS COMPUTER USES THE SMALLER VALUE.')
      IF (I1MACH(13).GE.500) WRITE(LUN,26)
   26 FORMAT('0ON COMPUTERS WITH MAXIMUM EXPONENT LESS THAN 150, A'/
     1' SMALL TEST VALUE FOR NU IS USED. IF LARGER THAN OR EQUAL 150,'/
     2' A LARGER NU IS USED. THIS COMPUTER USES THE LARGER VALUE.')
  150 CONTINUE
      NUDIFF=5
      MU1=DNU1
      MU2=MU1
      DEG=0.1
      THETA=DEG*4.*ATAN(1.0)/180.0
C
C In TEST 1 the Legendre functions P (of both positive and negative
C order) and Q are calculated.  Large values of mu and nu are used
C so that it is necessary to use extended range arithmetic.  The
C values of the Casoratians should be approximately equal to 1.0.
C The check which is applied is to verify that the difference between
C the Casoratians and 1.0 is less that 10.**(6-NDEC), where NDEC =
C INT((D-1)*LOG10(R)), D = I1MACH(11) = significand length, R =
C I1MACH(10) = radix.  This test uses
C the programs XSLEGF, XSPQNU, XSPSI, XSQNU, XSPMUP, XSSET, XSADD,
C XSADJ, XSCSRT, XSRED, XSC210, and XSCON.
C
      NDEC = INT( REAL(I1MACH(11)-1) * LOG10(REAL(I1MACH(10))) )
      IF (KPRINT.GT.2) WRITE(LUN,2)
    2 FORMAT(/'0TEST 1,FIXED MU,RECURRENCE IN NU,',
     1 'CASORATIS SHOULD = 1.0')
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,2,Q,IQ)
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,3,R,IR)
      CALL XSCSRT(DNU1,NUDIFF,MU1,MU2,THETA,P,Q,R,IP,IQ,IR,
     1 C1,IC1,C2,IC2)
      DO 20 I=1,6
      CALL XSCON(P(I),IP(I))
      CALL XSCON(Q(I),IQ(I))
      CALL XSCON(R(I),IR(I))
   20 CONTINUE
      X11=P(1)
      IX11=IP(1)
      X12=R(1)
      IX12=IR(1)
      X13=Q(1)
      IX13=IQ(1)
      IF(KPRINT.GT.2) THEN
        WRITE(LUN,3)
    3   FORMAT('0  THETA',6X,'NU',5X,'MU',17X,'P(-MU,NU)',23X,'P(MU,NU)'
     1  ,23X,'Q(MU,NU)'/ )
        NU=DNU1
        DO 25 I=1,6
        WRITE(LUN,4) DEG,NU,MU1,P(I),IP(I),R(I),IR(I),Q(I),IQ(I)
    4   FORMAT(1X,F8.2,F8.1,I6,3(E26.8,I7))
        NU=NU+1.
   25   CONTINUE
        WRITE(LUN,5)
    5   FORMAT('0  THETA',6X,'NU',5X,'MU',41X,'CASORATI 2',
     1  23X,'CASORATI 1'/)
        NU=DNU1
        DO 30 I=1,5
        WRITE(LUN,6) DEG,NU,MU1,C2(I),IC2(I),C1(I),IC1(I)
    6   FORMAT(1X,F8.2,F8.1,I6,33X,2(E26.8,I7))
        NU=NU+1.
   30   CONTINUE
      ENDIF
      DO 35 I=1,5
      IF(ABS(1.0-C1(I)).GE.10.0E0**(6-NDEC)) GO TO 40
      IF(ABS(1.0-C2(I)).GE.10.0E0**(6-NDEC)) GO TO 40
   35 CONTINUE
      IF (KPRINT.GE.2) WRITE(LUN,8)
    8 FORMAT(' ***** TEST 1 (SINGLE PRECISION) PASSED *****')
      GO TO 50
   40 IF(KPRINT.GE.1) WRITE(LUN,7)
    7 FORMAT(' ***** TEST 1 (SINGLE PRECISION) FAILED *****')
      IPASS=2
      IERR=IERR+1
   50 NUDIFF=0
      MU1=MU2-5
C
C In TEST 2 P (of positive and negative order) and Q are again
C calculated but in this test the recurrence is in the mu-wise direction
C rather than in the nu-wise direction as was the case before.  The same
C programs are used except that XSQNU is not used and XSQMU and XSPMU
C are used. Again the criterion for passing the test is that the
C Casoratians differ from 1.0 by less than 10.0**(6-NDEC).
C
      IF (KPRINT.GT.2) WRITE(LUN,9)
    9 FORMAT('0TEST 2,FIXED NU,RECURRENCE IN MU,',
     1'CASORATIS SHOULD = 1.0'/)
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,2,Q,IQ)
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,3,R,IR)
      CALL XSCSRT(DNU1,NUDIFF,MU1,MU2,THETA,P,Q,R,IP,IQ,IR,
     1 C1,IC1,C2,IC2)
      DO 60 I=1,6
      CALL XSCON(P(I),IP(I))
      CALL XSCON(Q(I),IQ(I))
      CALL XSCON(R(I),IR(I))
   60 CONTINUE
      X21=P(6)
      IX21=IP(6)
      X22=R(6)
      IX22=IR(6)
      X23=Q(6)
      IX23=IQ(6)
      IF(KPRINT.GT.2) THEN
        WRITE(LUN,3)
        MU=MU1
        DO 65 I=1,6
        WRITE(LUN,4) DEG,DNU1,MU,P(I),IP(I),R(I),IR(I),Q(I),IQ(I)
        MU=MU+1
   65   CONTINUE
        WRITE(LUN,10)
   10   FORMAT(/'0  THETA',6X,'NU',5X,'MU',41X,'CASORATI 4',
     1  23X,'CASORATI 3')
        MU=MU1
        DO 70 I=1,5
        WRITE(LUN,6) DEG,DNU1,MU,C2(I),IC2(I),C1(I),IC1(I)
        MU=MU+1
   70   CONTINUE
      ENDIF
      DO 75 I=1,5
      IF(ABS(1.0-C1(I)).GE.10.0E0**(6-NDEC)) GO TO 80
      IF(ABS(1.0-C2(I)).GE.10.0E0**(6-NDEC)) GO TO 80
   75 CONTINUE
      IF(KPRINT.GE.2) WRITE(LUN,12)
   12 FORMAT(' ***** TEST 2 (SINGLE PRECISION) PASSED *****')
      GO TO 85
   80 IF(KPRINT.GE.1) WRITE(LUN,11)
   11 FORMAT(' ***** TEST 2 (SINGLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
C
C In TEST 3 values of P and Q which were calculated in two different
C manners, one by nu-wise recurrence in TEST 1 and one by mu-wise
C recurrence in TEST 2, are compared.  Again, the criterion for success
C is a relative error of less than 10.0**(6-NDEC).
C
   85 IF (KPRINT.GT.2) THEN
      WRITE(LUN,13)
   13 FORMAT(/'0TEST 3, COMPARISON OF VALUES FROM TEST1 AND TEST 2'/
     1         ' FIRST LINE IS FROM TEST 1, SECOND FROM TEST 2')
      WRITE(LUN,3)
      WRITE(LUN,4) DEG,DNU1,MU2,X11,IX11,X12,IX12,X13,IX13
      WRITE(LUN,4) DEG,DNU1,MU2,X21,IX21,X22,IX22,X23,IX23
      ENDIF
      IF(ABS((X11-X21)/X11).GE.10.0E0**(6-NDEC)) GO TO 90
      IF(ABS((X12-X22)/X12).GE.10.0E0**(6-NDEC)) GO TO 90
      IF(ABS((X13-X13)/X13).GE.10.0E0**(6-NDEC)) GO TO 90
      IF(IX11.NE.IX21) GO TO 90
      IF(IX12.NE.IX22) GO TO 90
      IF(IX13.NE.IX23) GO TO 90
      IF(KPRINT.GE.2) WRITE(LUN,15)
   15 FORMAT(' ***** TEST 3 (SINGLE PRECISION) PASSED *****')
      GO TO 100
   90 IF(KPRINT.GE.1) WRITE(LUN,16)
   16 FORMAT(' ***** TEST 3 (SINGLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
  100 CONTINUE
C
C In TEST 4, the value of the normalized Legendre function as
C calculated by XSLEGF and XSPNRM is compared to the same value
C as calculated by the program XSNRMP.  Again the criterion is a
C relative error of less than 10.0**(6-NDEC).
C
      DNU1=100.0
      NUDIFF=0
      MU1=10
      MU2=10
      IF(KPRINT.GT.2) WRITE(LUN,17)
   17 FORMAT(/'0TEST 4, COMPARISON OF VALUES FROM XSLEGF AND XSNRMP'/
     1 ' VALUE ON THE LEFT WAS CALCULATED BY XSLEGF AND XSPNRM,'/
     2 ' VALUE ON THE RIGHT WAS CALCULATED BY XSNRMP.')
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,4,PN,IPN)
      X11=PN(1)
      IX11=IPN(1)
      NU1=100
      CALL XSNRMP(NU1,MU1,MU2,THETA,2,PN,IPN,ISIG)
      X21=PN(1)
      IX21=IPN(1)
      IF(KPRINT.GT.2) WRITE(LUN,4) DEG,DNU1,MU1,X11,IX11,X21,IX21
      IF(ABS((X11-X21)/X11).GE.10.0E0**(6-NDEC)) GO TO 110
      IF(IX11.NE.IX21) GO TO 110
      IF(KPRINT.GE.2) WRITE(LUN,18)
   18 FORMAT(' ***** TEST 4 (SINGLE PRECISION) PASSED *****')
      GO TO 120
  110 IF(KPRINT.GE.1) WRITE(LUN,19)
   19 FORMAT(' ***** TEST 4 (SINGLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
  120 CONTINUE
C
C In TEST 5 errors are purposely made in input so as to test error
C handling capability. First, an incorrect value of ID is given. Then
C both NUDIFF and MU2-MU1 are non-zero. Finally, an incorrect value
C of THETA is given.
C
      CALL XSETF(-1)
      IF (KPRINT.LE.2) CALL XSETF(0)
      IF (KPRINT.GT.2) WRITE(LUN,23)
   23 FORMAT(/'0TEST 5, TEST OF ERROR HANDLING. 3 ERROR MESSAGES SHOULD
     1BE PRINTED.')
      NUDIFF=0
      MU2=MU1
      ID=5
      CALL XERCLR
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,ID,P,IP)
      N=NUMXER(NERR)
      IF (N.NE.1) GO TO 125
      MU2=MU1+5
      NUDIFF=5
      CALL XERCLR
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      N=NUMXER(NERR)
      IF(N.NE.1) GO TO 125
      NUDIFF=0
      MU2=MU1
      THETA=2.0
      CALL XERCLR
      CALL XSLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      N=NUMXER(NERR)
      IF(N.NE.2) GO TO 125
      IF(KPRINT.GE.2) WRITE(LUN,28)
   28 FORMAT(' ***** TEST 5 (SINGLE PRECISION) PASSED *****')
      GO TO 135
  125 IF(KPRINT.GE.2) WRITE(LUN,29)
   29 FORMAT(' ***** TEST 5 (SINGLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
  135 CONTINUE
      IF(IERR.EQ.0) GO TO 130
      IF(KPRINT.GE.1) WRITE(LUN,21) IERR
   21 FORMAT(/'0 TESTS COMPLETED, NUMBER OF TESTS FAILED = ',I2)
      GO TO 140
  130 IF(KPRINT.GT.1) WRITE(LUN,22)
   22 FORMAT(/'0 --- ALL SINGLE PRECISION TESTS PASSED --- ')
  140 CONTINUE
      RETURN
      END
      SUBROUTINE FCNQX2(KPRINT,IPASS)
      INTEGER KPRINT,IPASS
      COMMON/UNIT/LUN
      DIMENSION P(10),Q(10),R(10),C1(10),C2(10),IP(10),IQ(10),IR(10)
      DIMENSION IC1(10),IC2(10),PN(10),IPN(10)
      DOUBLE PRECISION P,Q,R,C1,C2,PN
      DOUBLE PRECISION DEG,THETA,DNU1,DZERO
      DOUBLE PRECISION X11,X12,X13,X21,X22,X23
      REAL NU
      IF(KPRINT.GE.2) WRITE(LUN,1)
    1 FORMAT(' ** TEST DOUBLE PRECISION LEGENDRE FUNCTION ROUTINES IN FC
     1NPAK ** '/)
      IPASS=1
      IRAD=0
      NRADPL=0
      DZERO=0.0D0
      NBITS=0
      CALL XDSET(IRAD,NRADPL,DZERO,NBITS)
      IERR=0
      DNU1=2000.4D0
      IF(I1MACH(16)*LOG10(FLOAT(I1MACH(10))).LT.150) DNU1=100.4
      IF (KPRINT.LE.2) GO TO 150
      IF (I1MACH(16).LT.500) WRITE(LUN,24)
   24 FORMAT('0ON COMPUTERS WITH MAXIMUM EXPONENT LESS THAN 150, A'/
     1' SMALL TEST VALUE FOR NU IS USED. IF LARGER THAN OR EQUAL 150,'/
     2' A LARGER NU IS USED. THIS COMPUTER USES THE SMALLER VALUE.')
      IF (I1MACH(16).GE.500) WRITE(LUN,26)
   26 FORMAT('0ON COMPUTERS WITH MAXIMUM EXPONENT LESS THAN 150, A'/
     1' SMALL TEST VALUE FOR NU IS USED. IF LARGER THAN OR EQUAL 150,'/
     2' A LARGER NU IS USED. THIS COMPUTER USES THE LARGER VALUE.')
  150 CONTINUE
      NUDIFF=5
      MU1=DNU1
      MU2=MU1
      DEG=0.1D0
      THETA=DEG*4.D0*DATAN(1.0D0)/180.0D0
C
C In TEST 1 the Legendre functions P (of both positive and negative
C order) and Q are calculated.  Large values of mu and nu are used
C so that it is necessary to use extended range arithmetic.  The
C values of the Casoratians should be approximately equal to 1.0.
C The check which is applied is to verify that the difference between
C the Casoratians and 1.0 is less that 10.**(6-NDEC), where NDEC =
C INT((D-1)*LOG10(R)), D = I1MACH(14) = significand length, R =
C I1MACH(10) = radix.  This test uses
C the programs XDLEGF, XDPQNU, XDPSI, XDQNU, XDPMUP, XDSET, XDADD,
C XDADJ, XDCSRT, XDRED, XDC210, and XDCON.
C
      NDEC = INT( REAL(I1MACH(14)-1) * LOG10(REAL(I1MACH(10))) )
      IF(KPRINT.GT.2) WRITE(LUN,2)
    2 FORMAT(/'0TEST 1,FIXED MU,RECURRENCE IN NU,'
     1,' CASORATIS SHOULD = 1.0')
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,2,Q,IQ)
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,3,R,IR)
      CALL XDCSRT(DNU1,NUDIFF,MU1,MU2,THETA,P,Q,R,IP,IQ,IR,
     1 C1,IC1,C2,IC2)
      DO 20 I=1,6
      CALL XDCON(P(I),IP(I))
      CALL XDCON(Q(I),IQ(I))
      CALL XDCON(R(I),IR(I))
   20 CONTINUE
      X11=P(1)
      IX11=IP(1)
      X12=R(1)
      IX12=IR(1)
      X13=Q(1)
      IX13=IQ(1)
      IF (KPRINT.GT.2) WRITE(LUN,3)
    3 FORMAT(/'0  THETA',6X,'NU',5X,'MU',17X,'P(-MU,NU)',23X,'P(MU,NU)'
     1 ,23X,'Q(MU,NU)' )
      NU=DNU1
      IF(KPRINT.GT.2) THEN
      DO 25 I=1,6
      WRITE(LUN,4) DEG,NU,MU1,P(I),IP(I),R(I),IR(I),Q(I),IQ(I)
    4 FORMAT(1X,F8.2,F8.1,I6,3(D26.18,I7))
      NU=NU+1.
   25 CONTINUE
      WRITE(LUN,5)
      ENDIF
    5 FORMAT(/'0  THETA',6X,'NU',5X,'MU',41X,'CASORATI 2',
     123X,'CASORATI 1')
      NU=DNU1
      IF(KPRINT.GT.2) THEN
      DO 30 I=1,5
      WRITE(LUN,6) DEG,NU,MU1,C2(I),IC2(I),C1(I),IC1(I)
    6 FORMAT(1X,F8.2,F8.1,I6,33X,2(D26.18,I7))
      NU=NU+1.
   30 CONTINUE
      ENDIF
      DO 35 I=1,5
      IF(DABS(1.0D0-C1(I)).GE.10.0D0**(6-NDEC)) GO TO 40
      IF(DABS(1.0D0-C2(I)).GE.10.0D0**(6-NDEC)) GO TO 40
   35 CONTINUE
      IF(KPRINT.GE.2) WRITE(LUN,8)
    8 FORMAT(' ***** TEST 1 (DOUBLE PRECISION) PASSED *****')
      GO TO 50
   40 IF(KPRINT.GE.1) WRITE(LUN,7)
    7 FORMAT(' ***** TEST 1 (DOUBLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
   50 NUDIFF=0
      MU1=MU2-5
C
C In TEST 2 P (of positive and negative order) and Q are again
C calculated but in this test the recurrence is in the mu-wise direction
C rather than in the nu-wise direction as was the case before.  The same
C programs are used except that XDQNU is not used and XDQMU and XDPMU
C are used. Again the criterion for passing the test is that the
C Casoratians differ from 1.0 by less than 10.0**(6-NDEC).
C
      IF(KPRINT.GT.2) WRITE(LUN,9)
    9 FORMAT(/'0TEST 2,FIXED NU,RECURRENCE IN MU,',
     1'CASORATIS SHOULD = 1.0')
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,2,Q,IQ)
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,3,R,IR)
      CALL XDCSRT(DNU1,NUDIFF,MU1,MU2,THETA,P,Q,R,IP,IQ,IR,
     1 C1,IC1,C2,IC2)
      DO 60 I=1,6
      CALL XDCON(P(I),IP(I))
      CALL XDCON(Q(I),IQ(I))
      CALL XDCON(R(I),IR(I))
   60 CONTINUE
      X21=P(6)
      IX21=IP(6)
      X22=R(6)
      IX22=IR(6)
      X23=Q(6)
      IX23=IQ(6)
      IF(KPRINT.GT.2) WRITE(LUN,3)
      MU=MU1
      IF(KPRINT.GT.2) THEN
        DO 65 I=1,6
        WRITE(LUN,4) DEG,DNU1,MU,P(I),IP(I),R(I),IR(I),Q(I),IQ(I)
        MU=MU+1
   65   CONTINUE
        WRITE(LUN,10)
   10   FORMAT(/'0  THETA',6X,'NU',5X,'MU',41X,'CASORATI 4',
     1  23X,'CASORATI 3')
        MU=MU1
        DO 70 I=1,5
        WRITE(LUN,6) DEG,DNU1,MU,C2(I),IC2(I),C1(I),IC1(I)
        MU=MU+1
   70   CONTINUE
      ENDIF
      DO 75 I=1,5
      IF(DABS(1.0D0-C1(I)).GE.10.0D0**(6-NDEC)) GO TO 80
      IF(DABS(1.0D0-C2(I)).GE.10.0D0**(6-NDEC)) GO TO 80
   75 CONTINUE
      IF(KPRINT.GE.2) WRITE(LUN,12)
   12 FORMAT(' ***** TEST 2 (DOUBLE PRECISION) PASSED *****')
      GO TO 85
   80 WRITE(LUN,11)
   11 FORMAT(' ***** TEST 2 (DOUBLE PRECISION) FAILED *****')
      IPASS=2
      IERR=IERR+1
C
C In TEST 3 values of P and Q which were calculated in two different
C manners, one by nu-wise recurrence in TEST 1 and one by mu-wise
C recurrence in TEST 2, are compared.  Again, the criterion for success
C is a relative error of less than 10.0**(6-NDEC).
C
   85 IF(KPRINT.GT.2) THEN
        WRITE(LUN,13)
   13   FORMAT('/0TEST 3, COMPARISON OF VALUES FROM TEST1 AND TEST 2'/
     1         ' FIRST LINE IS FROM TEST 1, SECOND FROM TEST 2'/)
        WRITE(LUN,3)
        WRITE(LUN,4) DEG,DNU1,MU2,X11,IX11,X12,IX12,X13,IX13
        WRITE(LUN,4) DEG,DNU1,MU2,X21,IX21,X22,IX22,X23,IX23
      ENDIF
      IF(DABS((X11-X21)/X11).GE.10.0D0**(6-NDEC)) GO TO 90
      IF(DABS((X12-X22)/X12).GE.10.0D0**(6-NDEC)) GO TO 90
      IF(DABS((X13-X23)/X13).GE.10.0D0**(6-NDEC)) GO TO 90
      IF(IX11.NE.IX21) GO TO 90
      IF(IX12.NE.IX22) GO TO 90
      IF(IX13.NE.IX23) GO TO 90
      IF(KPRINT.GE.2) WRITE(LUN,15)
   15 FORMAT(' ***** TEST 3 (DOUBLE PRECISION) PASSED *****')
      GO TO 100
   90 IF(KPRINT.GE.1) WRITE(LUN,16)
   16 FORMAT(' ***** TEST 3 (DOUBLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
  100 CONTINUE
C
C In TEST 4, the value of the normalized Legendre function as
C calculated by XDLEGF and XDPNRM is compared to the same value
C as calculated by the program XDNRMP.  Again the criterion is a
C relative error of less than 10.0**(6-NDEC).
C
      DNU1=100.0D0
      NUDIFF=0
      MU1=10
      MU2=10
      IF(KPRINT.GT.2) WRITE(LUN,17)
   17 FORMAT('/0TEST 4, COMPARISON OF VALUES FROM XDLEGF AND XDNRMP'/
     1 ' VALUE ON THE LEFT WAS CALCULATED BY XDLEGF,'/
     2 ' VALUE ON THE RIGHT WAS CALCULATED BY XDNRMP.')
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,4,PN,IPN)
      X11=PN(1)
      IX11=IPN(1)
      NU1=100
      CALL XDNRMP(NU1,MU1,MU2,THETA,2,PN,IPN,ISIG)
      X21=PN(1)
      IX21=IPN(1)
      IF(KPRINT.GT.2) WRITE(LUN,4) DEG,DNU1,MU1,X11,IX11,X21,IX21
      IF(DABS((X11-X21)/X11).GE.10.0D0**(6-NDEC)) GO TO 110
      IF(IX11.NE.IX21) GO TO 110
      IF(KPRINT.GE.2) WRITE(LUN,18)
   18 FORMAT(' ***** TEST 4 (DOUBLE PRECISION) PASSED *****')
      GO TO 120
  110 IF(KPRINT.GE.1) WRITE(LUN,19)
   19 FORMAT(' ***** TEST 4 (DOUBLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
  120 CONTINUE
C
C In TEST 5 errors are purposely made in input so as to test error
C handling capability. First, an incorrect value of ID is given. Then
C both NUDIFF and MU2-MU1 are non-zero. Finally, an incorrect value
C of THETA is given.
C
      CALL XSETF(-1)
      IF (KPRINT.LE.2) CALL XSETF(0)
      IF (KPRINT.GT.2) WRITE(LUN,23)
   23 FORMAT(/'0TEST 5, TEST OF ERROR HANDLING. 3 ERROR MESSAGES SHOULD
     1BE PRINTED.')
      NUDIFF=0
      MU2=MU1
      ID=5
      CALL XERCLR
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,ID,P,IP)
      N=NUMXER(NERR)
      IF (N.NE.1) GO TO 125
      MU2=MU1+5
      NUDIFF=5
      CALL XERCLR
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      N=NUMXER(NERR)
      IF(N.NE.1) GO TO 125
      NUDIFF=0
      MU2=MU1
      THETA=2.0D0
      CALL XERCLR
      CALL XDLEGF(DNU1,NUDIFF,MU1,MU2,THETA,1,P,IP)
      N=NUMXER(NERR)
      IF(N.NE.2) GO TO 125
      IF(KPRINT.GE.2) WRITE(LUN,28)
   28 FORMAT(' ***** TEST 5 (DOUBLE PRECISION) PASSED *****')
      GO TO 135
  125 IF(KPRINT.GE.2) WRITE(LUN,29)
   29 FORMAT(' ***** TEST 5 (DOUBLE PRECISION) FAILED *****')
      IERR=IERR+1
      IPASS=2
  135 CONTINUE
      IF(IERR.EQ.0) GO TO 130
      IF(KPRINT.GE.2) WRITE(LUN,21) IERR
   21 FORMAT(/'0 TESTS COMPLETED, NUMBER OF TESTS FAILED = ',I2)
      GO TO 140
  130 IF(KPRINT.GT.1) WRITE(LUN,22)
   22 FORMAT(/'0 --- ALL DOUBLE PRECISION TESTS PASSED --- ')
  140 CONTINUE
      RETURN
      END
