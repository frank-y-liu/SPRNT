C
C   DRIVER FOR TESTING CMLIB ROUTINES
C      BVALUE   CV       FC
C      LSEI
C
C    ONE INPUT DATA CARD IS REQUIRED
C         READ(LIN,1) KPRINT,TIMES
C    1    FORMAT(I1,E10.0)
C
C     KPRINT = 0   NO PRINTING
C              1   NO PRINTING FOR PASSED TESTS, SHORT MESSAGE
C                  FOR FAILED TESTS
C              2   PRINT SHORT MESSAGE FOR PASSED TESTS, FULLER
C                  INFORMATION FOR FAILED TESTS
C              3   PRINT COMPLETE QUICK-CHECK RESULTS
C
C                ***IMPORTANT NOTE***
C         ALL QUICK CHECKS USE ROUTINES R2MACH AND D2MACH
C         TO SET THE ERROR TOLERANCES.
C     TIMES IS A CONSTANT MULTIPLIER THAT CAN BE USED TO SCALE THE
C     VALUES OF R1MACH AND D1MACH SO THAT
C               R2MACH(I) = R1MACH(I) * TIMES   FOR I=3,4,5
C               D2MACH(I) = D1MACH(I) * TIMES   FOR I=3,4,5
C     THIS MAKES IT EASILY POSSIBLE TO CHANGE THE ERROR TOLERANCES
C     USED IN THE QUICK CHECKS.
C     IF TIMES .LE. 0.0 THEN TIMES IS DEFAULTED TO 1.0
C
C              ***END NOTE***
C
      COMMON/UNIT/LUN
      COMMON/MSG/ICNT,JTEST(38)
      COMMON/XXMULT/TIMES
      LUN=I1MACH(2)
      LIN=I1MACH(1)
      ITEST=1
C
C     READ KPRINT,TIMES PARAMETERS FROM DATA CARD..
C
      READ(LIN,1) KPRINT,TIMES
1     FORMAT(I1,E10.0)
      IF(TIMES.LE.0.) TIMES=1.
      CALL XSETUN(LUN)
      CALL XSETF(1)
      CALL XERMAX(1000)
      IF(KPRINT.LE.1) CALL XSETF(0)
C   TEST FC
      CALL FCQX(KPRINT,IPASS)
      ITEST=ITEST*IPASS
C   TEST LSEI
      CALL LSEIQX(KPRINT,IPASS)
      ITEST=ITEST*IPASS
C
      IF(KPRINT.GE.1.AND.ITEST.NE.1) WRITE(LUN,2)
2     FORMAT(/,' ***** WARNING -- AT LEAST ONE TEST FOR SUBLIBRARY FC FA
     1ILED ***** ')
      IF(KPRINT.GE.1.AND.ITEST.EQ.1) WRITE(LUN,3)
3     FORMAT(/,' ----- SUBLIBRARY FC PASSED ALL TESTS ----- ')
      END
      DOUBLE PRECISION FUNCTION D2MACH(I)
      DOUBLE PRECISION D1MACH
      COMMON/XXMULT/TIMES
      D2MACH=D1MACH(I)
      IF(I.EQ.1.OR. I.EQ.2) RETURN
      D2MACH = D2MACH * DBLE(TIMES)
      RETURN
      END
      SUBROUTINE FCQX (KPRINT,IPASS)
C
C*********************************FCQX**********************************
C
C     QUICK CHECK SUBPROGRAM FOR THE SUBROUTINE FC.
C     DATE AUGUST, 1978.  SANDIA LABS, ALBUQUERQUE.
C     LAST UPDATE -- JAN 1980 BY LEE WALTON.
C                    MAR 1988 BY RON BOISVERT (FIXED DIAGNOSTIC CHECKS)
C                    JUN 1992 BY RON BOISVERT (FIXED ENDPOINT OF TEST2)
C     AUTHOR R. J. HANSON
C
C     FIT DISCRETE DATA BY AN S-SHAPED
C     CURVE. EVALUATE THE FITTED CURVE,
C     ITS FIRST TWO DERIVATIVES, AND PROBABLE
C     ERROR CURVE.
C
C     USE SUBPROGRAM FC( ) TO OBTAIN
C     THE CONSTRAINED CUBIC B-SPLINE
C     REPRESENTATION OF THE CURVE.
C
C     THE VALUES OF THE COEFFICIENTS OF THE B-SPLINE AS COMPUTED
C     BY FC( ) AND THE VALUES OF THE FITTED CURVE AS COMPUTED BY BVALUE
C     IN THE DE BOOR PACKAGE ARE TESTED FOR ACCURACY WITH THE EXPECTED
C     VALUES.  SEE EXAMPLE PROGRAM SAND78-1291, PP.22-27.
C
C***********************************************************************
C
C     THE DIMENSIONS IN THE FOLLOWING ARRAYS ARE AS SMALL
C     AS POSSIBLE FOR THE PROBLEM BEING SOLVED.
      DIMENSION XDATA(09),YDATA(09),SDDATA(09)
      DIMENSION BKPT(13),XCONST(11),YCONST(11),NDERIV(11),COEFF(09)
      DIMENSION V(51,5)
      DIMENSION W(529),IW(30)
      DIMENSION CHECK(51),COEFCK(9),ITEST(38)
      COMMON /MSG/ ICNT,ITEST
C     OUTPUT UNIT TO BE USED
      COMMON /UNIT/ NOUT
C
      DATA XDATA(1),XDATA(2),XDATA(3),XDATA(4),XDATA(5),
     1     XDATA(6),XDATA(7),XDATA(8),XDATA(9)
     2 /0.15,0.27,0.33,0.40,0.43,0.47,0.53,0.58,0.63/
      DATA YDATA(1),YDATA(2),YDATA(3),YDATA(4),YDATA(5),
     1     YDATA(6),YDATA(7),YDATA(8),YDATA(9)
     2 /0.025,0.05,0.13,0.27,0.37,0.47,0.64,0.77,0.87/
      DATA SDDATA(1) /0.015 /,NDATA/09/,NORD/04/,NBKPT/13/,LAST/10/
      DATA BKPT(1),BKPT(2),BKPT(3),BKPT(4),BKPT(5),
     1     BKPT(6),BKPT(7),BKPT(8),BKPT(9),BKPT(10),
     2     BKPT(11),BKPT(12),BKPT(13)
     3 /-0.6,-0.4,-0.2,0.,0.2,0.4,0.6,0.8,0.9,1.0,1.1,1.2,1.3/
C
C     STORE THE DATA TO BE USED TO CHECK THE ACCURACY OF THE
C     COMPUTED RESULTS.  SEE SAND78-1291, P.26.
C
      DATA COEFCK(1),COEFCK(2),COEFCK(3),COEFCK(4),COEFCK(5),
     1     COEFCK(6),COEFCK(7),COEFCK(8),COEFCK(9)/  1.186380846E-13,
     2          -2.826166426E-14, -4.333929094E-15,  1.722113311E-01,
     3           9.421965984E-01,  9.684708719E-01,  9.894902905E-01,
     4           1.005254855E+00,  9.894902905E-01/
      DATA CHECK(1), CHECK(2), CHECK(3), CHECK(4), CHECK(5),
     1     CHECK(6), CHECK(7), CHECK(8), CHECK(9)/
     2     2.095830752E-16, 2.870188850E-05, 2.296151081E-04,
     3     7.749509897E-04, 1.836920865E-03, 3.587736064E-03,
     4     6.199607918E-03, 9.844747759E-03, 1.469536692E-02/
      DATA CHECK(10), CHECK(11), CHECK(12), CHECK(13), CHECK(14),
     1     CHECK(15), CHECK(16), CHECK(17), CHECK(18)/
     2     2.092367672E-02, 2.870188851E-02, 3.824443882E-02,
     3     4.993466504E-02, 6.419812979E-02, 8.146039566E-02,
     4     1.021470253E-01, 1.266835812E-01, 1.554956261E-01/
      DATA CHECK(19), CHECK(20), CHECK(21), CHECK(22), CHECK(23),
     1     CHECK(24), CHECK(25), CHECK(26), CHECK(27)/
     2     1.890087225E-01, 2.276484331E-01, 2.718403204E-01,
     3     3.217163150E-01, 3.762338189E-01, 4.340566020E-01,
     4     4.938484342E-01, 5.542730855E-01, 6.139943258E-01/
      DATA CHECK(28), CHECK(29), CHECK(30), CHECK(31), CHECK(32),
     1     CHECK(33), CHECK(34), CHECK(35), CHECK(36)/
     2     6.716759250E-01, 7.259816530E-01, 7.755752797E-01,
     3     8.191205752E-01, 8.556270903E-01, 8.854875002E-01,
     4     9.094402609E-01, 9.282238286E-01, 9.425766596E-01/
      DATA CHECK(37), CHECK(38), CHECK(39), CHECK(40), CHECK(41),
     1     CHECK(42), CHECK(43), CHECK(44), CHECK(45)/
     2     9.532372098E-01, 9.609439355E-01, 9.664352927E-01,
     3     9.704497377E-01, 9.737257265E-01, 9.768786393E-01,
     4     9.800315521E-01, 9.831844649E-01, 9.863373777E-01/
      DATA CHECK(46), CHECK(47), CHECK(48), CHECK(49), CHECK(50),
     1     CHECK(51)/       9.894902905E-01, 9.926011645E-01,
     2     9.954598055E-01, 9.978139804E-01, 9.994114563E-01,
     3     1.000000000E+00/
C
C     BROADCAST SDDATA(1) VALUE TO ALL OF SDDATA(*).
      CALL SCOPY(NDATA,SDDATA,0,SDDATA,1)
      ZERO=0.
      ONE=1.
      NDEG=NORD-1
C
C     WRITE THE VARIOUS CONSTRAINTS FOR
C     THE FITTED CURVE.
      NCONST=0
      T=BKPT(NORD)
C
C     CONSTRAIN FUNCTION TO BE ZERO AT LEFT-MOST BREAKPOINT.
      NCONST=NCONST+1
      XCONST(NCONST) = T
      YCONST(NCONST) = ZERO
      NDERIV(NCONST) = 2+4*0
C
C     CONSTRAIN FIRST DERIVATIVE TO BE
C     NONNEGATIVE AT LEFT-MOST BREAKPOINT.
      NCONST=NCONST+1
      XCONST(NCONST) = T
      YCONST(NCONST) = ZERO
      NDERIV(NCONST) = 1+4*1
C
C     CONSTRAIN SECOND DERIVATIVES TO BE
C     NONNEGATIVE AT LEFT SET OF BREAKPOINTS.
        DO 10 I = 1, 3
        L=NDEG+I
        T=BKPT(L)
        NCONST=NCONST+1
        XCONST(NCONST) = T
        YCONST(NCONST) = ZERO
        NDERIV(NCONST) = 1+4*2
   10   CONTINUE
C
C     CONSTRAIN FUNCTION VALUE AT RIGHT-MOST
C     BREAKPOINT TO BE ONE.
      NCONST=NCONST+1
      T=BKPT(LAST)
      XCONST(NCONST) = T
      YCONST(NCONST) = ONE
      NDERIV(NCONST) = 2+4*0
C
C     CONSTRAIN SLOPE TO AGREE AT LEFT AND
C     RIGHT-MOST BREAKPOINTS.
      NCONST=NCONST+1
      XCONST(NCONST) = BKPT(NORD)
      YCONST(NCONST) = BKPT(LAST)
      NDERIV(NCONST) = 3+4*1
C
C     CONSTRAIN SECOND DERIVATIVES TO BE
C     NONPOSITIVE AT RIGHT SET OF BREAKPOINTS.
        DO 20 I = 1, 4
        NCONST=NCONST+1
        L=LAST-4+I
        XCONST(NCONST) = BKPT(L)
        YCONST(NCONST) = ZERO
        NDERIV(NCONST) = 0+4*2
   20   CONTINUE
C
      IF (KPRINT .GE. 2) WRITE (NOUT,1000)
 1000 FORMAT('1TEST OF SUBROUTINE FC')
      ICNT=1
      IDIGIT=-4
C
      IF (KPRINT .LT. 3) GO TO 30
      CALL SVOUT(NBKPT,BKPT,'(''1ARRAY OF KNOTS.'')',IDIGIT)
      CALL SVOUT(NDATA,XDATA,'(//'' INDEP. VAR. VALUES'')',IDIGIT)
      CALL SVOUT(NDATA,YDATA,'('' DEPEND. VAR. VALUES'')',IDIGIT)
      CALL SVOUT(NDATA,SDDATA,'('' DEPEND. VAR. UNCERTAINTY'')',IDIGIT)
C
      CALL SVOUT(NCONST,XCONST,'(''0INDEP. VAR. CONST. VALS.'')',IDIGIT)
      CALL SVOUT(NCONST,YCONST,'('' CONST. VALUES'')',IDIGIT)
      CALL IVOUT(NCONST,NDERIV,'('' CONST. INDICATOR'')',IDIGIT)
C
   30 CONTINUE
C
C     DECLARE AMOUNT OF WORKING STORAGE ALLOCATED TO FC( ).
      IW(1) = 529
      IW(2) = 30
C
C     SET MODE TO INDICATE A NEW PROBLEM
C     AND REQUEST THE VARIANCE FUNCTION.
      MODE=2
C
C     OBTAIN THE COEFFICIENTS OF THE B-SPLINE.
      CALL FC(NDATA,XDATA,YDATA,SDDATA,
     1        NORD,NBKPT,BKPT,
     2        NCONST,XCONST,YCONST,NDERIV,
     3        MODE,
     4        COEFF,
     5        W,IW)
C
C     CHECK COEFFICIENTS
C
        TOL = 10.E0*SQRT(R2MACH(3))
        DO 40 I = 1, NDATA
        DIFF=ABS(COEFF(I)-COEFCK(I))
        IF (.NOT.(DIFF .LE. TOL)) GO TO 50
   40   CONTINUE
      ITEST(ICNT) = 1
      IF (KPRINT .GE. 3) WRITE (NOUT,1001)
 1001 FORMAT('0FC( ) PASSED TEST 1')
      GO TO 60
C
   50 CONTINUE
      ITEST(ICNT) = 0
      IF (KPRINT .GE. 2) WRITE (NOUT,1002)
 1002 FORMAT('0FC( ) FAILED TEST 1')
C
   60 CONTINUE
      K = ITEST(ICNT)
      IF (KPRINT .EQ. 2 .AND. K .NE. 0) GO TO 70
      IF (KPRINT .LT. 2) GO TO 70
      CALL SVOUT(NDATA,COEFCK,'(/'' PREDICTED COEFFICIENTS OF THE B-SPLI
     1NE FROM SAMPLE'')',IDIGIT)
      CALL SVOUT(NDATA,COEFF,'(/'' COEFFICIENTS OF THE B-SPLINE COMPUTED
     1 BY FC( )'')',IDIGIT)
C
   70 CONTINUE
      ICNT=ICNT+1
C
C     COMPUTE VALUE, FIRST TWO DERIVS., AND PROBABLE UNCERTAINTY.
      N=NBKPT-NORD
      NVAL=51
      XVAL=ZERO
      DX=ONE/FLOAT(NVAL-1)
        DO 90 I = 1, NVAL
           IF (I .EQ. NVAL) XVAL = 1.0E0
C
C     THE FUNCTION BVALUE( ) IS IN THE DE BOOR B-SPLINE PACKAGE.
          DO 80 J = 1, 3
          V(I,J+1) = BVALUE(BKPT,COEFF,N,NORD,XVAL,J-1)
   80     CONTINUE
        V(I,1) = XVAL
C
C     THE VARIANCE FUNCTION CV( ) IS A COMPANION
C     SUBPROGRAM TO FC( ).
        V(I,5) = SQRT(CV(XVAL,NDATA,NCONST,NORD,NBKPT,BKPT,W))
        XVAL=XVAL+DX
   90   CONTINUE
C
        DO 100 I = 1, NVAL
        DIFF=ABS(V(I,2)-CHECK(I))
        IF (.NOT.(DIFF .LE. TOL)) GO TO 110
  100   CONTINUE
      ITEST(ICNT) = 1
      IF (KPRINT .GE. 3) WRITE (NOUT,1003)
 1003 FORMAT('0FC( ) (AND BVALUE) PASSED TEST 2')
      GO TO 120
C
  110 CONTINUE
      ITEST(ICNT) = 0
      IF (KPRINT .GE. 2) WRITE (NOUT,1004)
 1004 FORMAT('0FC( ) (AND BVALUE) FAILED TEST 2')
C
  120 CONTINUE
      K = ITEST(ICNT)
      IF (KPRINT .EQ. 2 .AND. K .NE. 0) GO TO 130
      IF (KPRINT .LT. 2) GO TO 130
C     PRINT THESE VALUES.
      CALL SMOUT(NVAL,5,NVAL,V,'(''1'',15X,''X'',10X,''FNCN'',08X,
     1''1ST D'',07X,''2ND D'',07X,''ERROR'')',
     2  IDIGIT)
      WRITE (NOUT,1005)
 1005 FORMAT('0VALUES SHOULD CORRESPOND TO THOSE IN SAND78-1291, P. 26')
  130 CONTINUE
C
C     CHECK ERROR PROCESSOR
C
      IF (KPRINT .LT. 2) GO TO 140
      WRITE (NOUT,1006)
 1006 FORMAT('0DIAGNOSTIC MESSAGES (6) FOR FC')
      CALL FC(NDATA,XDATA,YDATA,SDDATA,0,NBKPT,BKPT,NCONST,XCONST,
     1        YCONST,NDERIV,MODE,COEFF,W,IW)
      CALL FC(NDATA,XDATA,YDATA,SDDATA,NORD,0,BKPT,NCONST,XCONST,
     1        YCONST,NDERIV,MODE,COEFF,W,IW)
      CALL FC(-1,XDATA,YDATA,SDDATA,NORD,NBKPT,BKPT,NCONST,XCONST,
     1        YCONST,NDERIV,MODE,COEFF,W,IW)
      IW(1) = 529
      MODE = 0
      CALL FC(NDATA,XDATA,YDATA,SDDATA,NORD,NBKPT,BKPT,NCONST,XCONST,
     1        YCONST,NDERIV,MODE,COEFF,W,IW)
      IW(1) = 10
      CALL FC(NDATA,XDATA,YDATA,SDDATA,NORD,NBKPT,BKPT,NCONST,XCONST,
     1        YCONST,NDERIV,MODE,COEFF,W,IW)
      IW(1) = 529
      IW(2) = 2
      MODE = 2
      CALL FC(NDATA,XDATA,YDATA,SDDATA,NORD,NBKPT,BKPT,NCONST,XCONST,
     1        YCONST,NDERIV,MODE,COEFF,W,IW)
C
  140 CONTINUE
      IP=1
        DO 150 I = 1, ICNT
        IP=IP*ITEST(I)
  150   CONTINUE
        IPASS=IP
      IF (IPASS.EQ.1 .AND. KPRINT.GE.2) WRITE (NOUT,1007)
      IF (IPASS.EQ.0 .AND. KPRINT.GE.1) WRITE (NOUT,1008)
 1007 FORMAT(/' ***** FC PASSED ALL TESTS *****')
 1008 FORMAT(/' ***** FC FAILED SOME TESTS *****')
      RETURN
      END
      SUBROUTINE LSEIQX(KPRINT, IPASS)
C
C  ******************************** LSEIQX *****************************
C
C     QUICK CHECK SUBPROGRAM FOR THE SUBROUTINE LSEI.
C  DATE FEBRUARY 16, 1979.  SANDIA LABS, ALBUQUERQUE.
C  LAST UPDATE -- JANUARY, 1980 BY LEE WALTON.
C              -- April, 1996 by Ron Boisvert. Gave IP(1), IP(2) values
C  AUTHORS  R. J. HANSON,  KAREN HASKELL.
C
C     THE SAMPLE PROBLEM SOLVED IS FROM A PAPER BY J. STOER, IN
C     SIAM JOURNAL OF NUM. ANAL., JUNE 1971.
C
C  *********************************************************************
C
      DIMENSION D(11,6), IP(17), WORK(105), F(6)
      DIMENSION X(5), H(5), SOL(5), A(6,5), G(5,5)
      DIMENSION PRGOPT(4)
      DIMENSION ITEST(38)
      COMMON /MSG/ ICNT, ITEST
C     OUTPUT UNIT TO BE USED.
      COMMON /UNIT/ NOUT
C
C     DEFINE THE DATA ARRAYS FOR THE EXAMPLE.  THE ARRAY A( )
C     CONTAINS THE LEAST SQUARES EQUATIONS.  (THERE ARE NO EQUALITY
C     CONSTRAINTS IN THIS EXAMPLE).
      DATA A(1,1), A(1,2), A(1,3), A(1,4), A(1,5) /-74.,80.,18.,-11.,
     * -4./
      DATA A(2,1), A(2,2), A(2,3), A(2,4), A(2,5) /14.,-69.,21.,28.,0./
      DATA A(3,1), A(3,2), A(3,3), A(3,4), A(3,5) /66.,-72.,-5.,7.,1./
      DATA A(4,1), A(4,2), A(4,3), A(4,4), A(4,5) /-12.,66.,-30.,-23.,
     * 3./
      DATA A(5,1), A(5,2), A(5,3), A(5,4), A(5,5) /3.,8.,-7.,-4.,1./
      DATA A(6,1), A(6,2), A(6,3), A(6,4), A(6,5) /4.,-12.,4.,4.,0./
C
C     THE ARRAY G( ) CONTAINS THE INEQUALITY CONSTRAINT EQUATIONS,
C     WRITTEN IN THE SENSE
C     (ROW VECTOR)*(SOLUTION VECTOR) .GE. (GIVEN VALUE).
      DATA G(1,1), G(1,2), G(1,3), G(1,4), G(1,5) /-1.,-1.,-1.,-1.,-1./
      DATA G(2,1), G(2,2), G(2,3), G(2,4), G(2,5) /10.,10.,-3.,5.,4./
      DATA G(3,1), G(3,2), G(3,3), G(3,4), G(3,5) /-8.,1.,-2.,-5.,3./
      DATA G(4,1), G(4,2), G(4,3), G(4,4), G(4,5) /8.,-1.,2.,5.,-3./
      DATA G(5,1), G(5,2), G(5,3), G(5,4), G(5,5) /-4.,-2.,3.,-5.,1./
C
C     DEFINE THE LEAST SQUARES RIGHT-SIDE VECTOR.
      DATA F(1), F(2), F(3), F(4) /-5.,-9.,708.,4165./
      DATA F(5), F(6) /-13266.,8409./
C
C     DEFINE THE INEQUALITY CONSTRAINT RIGHT-SIDE VECTOR.
      DATA H(1), H(2), H(3), H(4), H(5) /-5.,20.,-40.,11.,-30./
C
C     DEFINE THE VECTOR THAT IS THE KNOWN SOLUTION.
      DATA SOL(1), SOL(2), SOL(3), SOL(4), SOL(5) /1.,2.,-1.,3.,-4./
C
C     DEFINE THE MATRIX DIMENSIONS, NUMBER OF LEAST SQUARES EQUATIONS,
C     NUMBER OF EQUALITY CONSTRAINTS, TOTAL NUMBER OF
C     EQUATIONS, AND NUMBER OF VARIABLES.  SET ME=0 TO INDICATE
C     THERE ARE NO EQUALITY CONSTRAINTS.
      MDD = 11
      MDA = 6
      MDG = 5
      MA = 6
      MG = 5
      M = MA + MG
      N = 5
      ME = 0
C
      ip(1) = 105
      ip(2) = 17
C
      NP1 = N + 1
      MEP1 = ME + 1
      MEAP1 = ME + MA + 1
C
C     COPY THE PROBLEM MATRICES
      DO 10 I = 1, N
C
C     COPY THE I-TH COL OF THE INEQUALITY CONSTRAINT MATRIX INTO
C     THE WORK ARRAY.
        CALL SCOPY(MG, G(1,I), 1, D(MEAP1,I), 1)
C
C     COPY THE I-TH COL OF THE LEAST SQUARES MATRIX INTO THE WORK
C     ARRAY.
        CALL SCOPY(MA, A(1,I), 1, D(MEP1,I), 1)
C
   10 CONTINUE
C
C     COPY THE RIGHT-SIDE VECTORS INTO THE WORK ARRAY IN COMPATIBLE
C     ORDER.
      CALL SCOPY(MG, H, 1, D(MEAP1,NP1), 1)
      CALL SCOPY(MA, F, 1, D(MEP1,NP1), 1)
C
      ICNT = 1
      IF (KPRINT.GE.2) WRITE (NOUT,99999)
99999 FORMAT ('1TEST OF SUBROUTINE LSEI')
C
C     USE DEFAULT PROGRAM OPTIONS IN LSEI( ), AND SET MATRIX-
C     VECTOR PRINTING ACCURACY PARAMETERS.
      PRGOPT(1) = 1
      IDIGIT = -4
      JDIGIT = -11
C
C     PRINT THE DATA MATRIX TO BE PASSED TO LSEI( ).
C     CALL SMOUT (MA,N+1,MDD,D,'(/'' LEAST SQUARES EQUATIONS  (ROWS 1-6)
C    1DATA VALUES (COL 6)'')',IDIGIT)
C     CALL SSMOUT (MA+1,1,M,N+1,MDD,D,'('' INEQUALITY CONSTRAINT EQUATIONS
C    1(ROWS 7-11)  CONSTRAINING VALUES (COL 6)'')',IDIGIT)
C
C     COMPUTE RESIDUAL NORM OF KNOWN LEAST SQUARES SOLN.  (TO BE
C     USED TO CHECK COMPUTED RESIDUAL NORM = RNORML.)
      DO 20 I = 1, MA
        WORK(I) = SDOT(N,D(I,1),MDD,SOL,1) - F(I)
   20 CONTINUE
      RESNRM = SNRM2(MA,WORK,1)
C
C     CALL LSEI( ) TO GET SOLN IN X(*), LEAST SQUARES RESIDUAL IN
C     RNORML.
      CALL LSEI(D, MDD, ME, MA, MG, N, PRGOPT, X, RNORME, RNORML, MODE,
     * WORK, IP)
C
C
C     COMPUTE REL. ERROR IN PROBLEM VARIABLE SOLN. AND RESIDUAL
C     NORM COMPUTATION.
      TNORM = SNRM2(N,SOL,1)
      CALL SAXPY(N, -1., X, 1, SOL, 1)
      CNORM = SNRM2(N,SOL,1)
      RELERR = CNORM/TNORM
      RELNRM = (RESNRM-RNORML)/RESNRM
C
      IF (.NOT.(RELERR.LE.100.*SQRT(R2MACH(3)))) GO TO 30
      IF (.NOT.(RELNRM.LE.10.*R2MACH(3))) GO TO 30
      IF (KPRINT.EQ.3) WRITE (NOUT,99998)
99998 FORMAT ('0LSEI PASSED TEST')
      ITEST(ICNT) = 1
      GO TO 40
C
   30 CONTINUE
      ITEST(ICNT) = 0
      IF (KPRINT.GE.2) WRITE (NOUT,99997)
99997 FORMAT ('0LSEI FAILED TEST')
C
   40 CONTINUE
      IF (KPRINT.LT.3) GO TO 50
C     PRINT OUT KNOWN SOLUTION AND COMPUTED SOLUTION
      CALL SVOUT(N, SOL, '('' KNOWN LEAST SQUARES SOLN'')', IDIGIT)
      CALL SVOUT(N, X, '(/'' SOLN COMPUTED BY LSEI( ).'')', JDIGIT)
C
   50 CONTINUE
      K = ITEST(ICNT)
      IF (KPRINT.EQ.2 .AND. K.NE.0) GO TO 60
      IF (KPRINT.LT.2) GO TO 60
C     PRINT OUT THE KNOWN AND COMPUTED RESIDUAL NORMS
      CALL SVOUT(1, RESNRM,
     * '(/'' RESIDUAL NORM OF KNOWN LEAST SQUARES SOLN'')', JDIGIT)
      CALL SVOUT(1, RNORML, '(/'' RES NORM COMPUTED BY LSEI( ) '')',
     * JDIGIT)
C     PRINT OUT THE COMPUTED SOLUTION RELATIVE ERROR
      CALL SVOUT(1, RELERR, '(/'' COMPUTED SOLN REL. ERROR'')', IDIGIT)
C     PRINT OUT THE COMPUTED RELATIVE ERROR IN RESIDUAL NORM
      CALL SVOUT(1, RELNRM,
     * '(/'' COMPUTED REL. ERROR IN RESIDUAL NORM'')', IDIGIT)
C
   60 CONTINUE
C
C     CHECK CALLS TO ERROR PROCESSOR
C
      IF (KPRINT.LT.2) GO TO 70
      WRITE (NOUT,99996)
99996 FORMAT (/' DIAGNOSTIC MESSAGES (3) FOR LSEI ')
      CALL LSEI(D, 0, ME, MA, MG, N, PRGOPT, X, RNORME, RNORML, MODE,
     * WORK, IP)
C     PRGOPT(1) = 4
C     PRGOPT(2) = 1
C     PRGOPT(3) = 1
C     PRGOPT(4) = 1
C     CALL LSEI (D,MDD,ME,MA,MG,12,PRGOPT,X,RNORME,RNORML,MODE,WORK,IP)
      PRGOPT(1) = -1
      CALL LSEI(D, MDD, ME, MA, MG, N, PRGOPT, X, RNORME, RNORML, MODE,
     * WORK, IP)
C
   70 CONTINUE
      IPASS = ITEST(ICNT)
      IF (IPASS.EQ.1 .AND. KPRINT.GE.2) WRITE (NOUT,99995)
      IF (IPASS.EQ.0 .AND. KPRINT.GE.1) WRITE (NOUT,99994)
99995 FORMAT (/' ***** LSEI PASSED ALL TESTS *****')
99994 FORMAT (/' ***** LSEI FAILED SOME TESTS ***** ')
C
      RETURN
      END
      REAL FUNCTION R2MACH(I)
      COMMON/XXMULT/TIMES
      R2MACH=R1MACH(I)
      IF(I.EQ.1.OR. I.EQ.2) RETURN
      R2MACH = R2MACH * TIMES
      RETURN
      END
      SUBROUTINE SMOUT(M,N,LDA,A,IFMT,IDIGIT)
C ...  DECLARATION REPLACED BY RON BOISVERT ON 6-NOV-91
C      DIMENSION A(LDA,N),IFMT(1),ICOL(3)
      DIMENSION A(LDA,N),ICOL(3)
      CHARACTER*(*) IFMT
C ...
C
C     SINGLE PRECISION MATRIX OUTPUT ROUTINE.
C
C  INPUT..
C
C  M,N,LDA,A(*,*) PRINT THE SINGLE PRECISION ARRAY A(I,J),I  = 1,...,M,
C                 J=1,...,N, ON OUTPUT UNIT LOUT=6. LDA IS THE DECLARED
C                 FIRST DIMENSION OF A(*,*) AS SPECIFIED IN THE CALLING
C                 PROGRAM. THE HEADING IN THE FORTRAN FORMAT STATEMENT
C                 IFMT(*), DESCRIBED BELOW, IS PRINTED AS A FIRST STEP.
C                 THE COMPONENTS A(I,J) ARE INDEXED, ON OUTPUT, IN A
C                 PLEASANT FORMAT.
C  IFMT(*)        A FORTRAN FORMAT STATEMENT. THIS IS PRINTED ON
C                 OUTPUT UNIT LOUT=6 WITH THE VARIABLE FORMAT FORTRAN
C                 STATEMENT
C                       WRITE(LOUT,IFMT).
C  IDIGIT         PRINT AT LEAST IABS(IDIGIT) DECIMAL DIGITS PER NUMBER.
C                 THE SUBPROGRAM WILL CHOOSE THAT INTEGER 4,6,10, OR 14
C                 WHICH WILL PRINT AT LEAST IABS(IDIGIT) NUMBER OF
C                 PLACES.  IF IDIGIT.LT.0, 72 PRINTING COLUMNS ARE
C                 UTILIZED TO WRITE EACH LINE OF OUTPUT OF THE ARRAY
C                 A(*,*). (THIS CAN BE USED ON MOST TIME-SHARING
C                 TERMINALS).  IF IDIGIT.GE.0, 133 PRINTING COLUMNS ARE
C                 UTILIZED. (THIS CAN BE USED ON MOST LINE PRINTERS).
C
C  EXAMPLE..
C
C  PRINT AN ARRAY CALLED (SIMPLEX TABLEAU   ) OF SIZE 10 BY 20 SHOWING
C  6 DECIMAL DIGITS PER NUMBER. THE USER IS RUNNING ON A TIME-SHARING
C  SYSTEM WITH A 72 COLUMN OUTPUT DEVICE.
C
C     DIMENSION TABLEU(20,20)
C     M = 10
C     N = 20
C     LDTABL = 20
C     IDIGIT = -6
C     CALL SMOUT(M,N,LDTABL,TABLEU,21H(16H1SIMPLEX TABLEAU),IDIGIT)
C
C
C
C     AUTHORS    JOHN A. WISNIEWSKI   SANDIA LABS ALBUQUERQUE.
C                RICHARD J. HANSON    SANDIA LABS ALBUQUERQUE.
C     DATE       JULY 27,1978.
C
C
      DATA ICOL(1),ICOL(2),ICOL(3)/1HC,1HO,1HL/
      LOUT=I1MACH(2)
      WRITE(LOUT,IFMT)
      IF(M.LE.0.OR.N.LE.0.OR.LDA.LE.0) RETURN
      NDIGIT = IDIGIT
      IF(IDIGIT.EQ.0) NDIGIT = 4
      IF(IDIGIT.GE.0) GO TO 80
C
      NDIGIT = -IDIGIT
      IF(NDIGIT.GT.4) GO TO 20
C
      DO 10 K1=1,N,5
      K2 = MIN0(N,K1+4)
      WRITE(LOUT,1000) (ICOL,I,I = K1, K2)
      DO 10 I = 1, M
      WRITE(LOUT,1004) I,(A(I,J),J = K1, K2)
   10 CONTINUE
      RETURN
C
   20 CONTINUE
      IF(NDIGIT.GT.6) GO TO 40
C
      DO 30 K1=1,N,4
      K2 = MIN0(N,K1+3)
      WRITE(LOUT,1001) (ICOL,I,I = K1, K2)
      DO 30 I = 1, M
      WRITE(LOUT,1005) I,(A(I,J),J = K1, K2)
   30 CONTINUE
      RETURN
C
   40 CONTINUE
      IF(NDIGIT.GT.10) GO TO 60
C
      DO 50 K1=1,N,3
      K2=MIN0(N,K1+2)
      WRITE(LOUT,1002) (ICOL,I,I = K1, K2)
      DO 50 I = 1, M
      WRITE(LOUT,1006) I,(A(I,J),J = K1, K2)
   50 CONTINUE
      RETURN
C
   60 CONTINUE
      DO 70 K1=1,N,2
      K2 = MIN0(N,K1+1)
      WRITE(LOUT,1003) (ICOL,I,I = K1, K2)
      DO 70 I = 1, M
      WRITE(LOUT,1007) I,(A(I,J),J = K1, K2)
   70 CONTINUE
      RETURN
C
   80 CONTINUE
      IF(NDIGIT.GT.4) GO TO 100
C
      DO 90 K1=1,N,10
      K2 = MIN0(N,K1+9)
      WRITE(LOUT,1000) (ICOL,I,I = K1, K2)
      DO 90 I = 1, M
      WRITE(LOUT,1004) I,(A(I,J),J = K1, K2)
   90 CONTINUE
      RETURN
C
  100 CONTINUE
      IF(NDIGIT.GT.6) GO TO 120
C
      DO 110 K1=1,N,8
      K2 = MIN0(N,K1+7)
      WRITE(LOUT,1001) (ICOL,I,I = K1, K2)
      DO 110 I = 1, M
      WRITE(LOUT,1005) I,(A(I,J),J = K1, K2)
  110 CONTINUE
      RETURN
C
  120 CONTINUE
      IF(NDIGIT.GT.10) GO TO 140
C
      DO 130 K1=1,N,6
      K2 = MIN0(N,K1+5)
      WRITE(LOUT,1002) (ICOL,I,I = K1, K2)
      DO 130 I = 1, M
      WRITE(LOUT,1006) I,(A(I,J),J = K1, K2)
  130 CONTINUE
      RETURN
C
  140 CONTINUE
      DO 150 K1=1,N,5
      K2 = MIN0(N,K1+4)
      WRITE(LOUT,1003) (ICOL,I,I = K1, K2)
      DO 150 I = 1, M
      WRITE(LOUT,1007) I,(A(I,J),J = K1, K2)
  150 CONTINUE
      RETURN
 1000 FORMAT(10X,10(4X,3A1,I4,1X))
 1001 FORMAT(10X,8(5X,3A1,I4,2X))
 1002 FORMAT(10X,6(7X,3A1,I4,4X))
 1003 FORMAT(10X,5(9X,3A1,I4,6X))
 1004 FORMAT(1X,'ROW',I4,2X,1P10E12.3)
 1005 FORMAT(1X,'ROW',I4,2X,1P8E14.5)
 1006 FORMAT(1X,'ROW',I4,2X,1P6E18.9)
 1007 FORMAT(1X,'ROW',I4,2X,1P5E22.13)
      END
